---
title: "joinAlphaAndBeta"
author: "caitlinpage"
date: "2025-10-01"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

## Description

Here I want to figure out how I am going to meaningfully link my alphas and betas
Do they go together in a data frame?
Do they follow more like a summarised experiment format with different sections?
(last discussion this was more likely)

Follows from previous beta file based analysis - figuring out betas [here](checkAlphaAndBeta.html), summarised beta decisions [here](bedFileBetas.html)

## Packages and files

```{r}
library(data.table)
library(plyranges)
library(tidyr)
library(reshape2)
library(stringr)
library(dplyr)
library(ggplot2)
```


```{r}
all_samples <- readRDS("/researchers/caitlin.page/cf_nano/r_output/all_samples.rds")
overlap_bins_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/overlap_bins_reads.rds")
cg_sites <- readRDS("/researchers/caitlin.page/cf_nano/r_output/cg_sites.rds")
bed_betas <- readRDS("/researchers/caitlin.page/cf_nano/r_output/bed_betas.rds")
indiv_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/indiv_reads.rds")
```

```{r}
bed_betas$pos <- paste0(bed_betas$seqnames, "-", bed_betas$start)
bed_betas_hu5.10 <- bed_betas %>% filter(sample == "hu5.10")
head(bed_betas_hu5.10)
```


## Filtering the files

(see previous work for decisions - but this is to make sure betas and alphas match up as expected)
```{r}
overlaps_bed_reads <- find_overlaps(as_granges(bed_betas_hu5.10), as_granges(indiv_reads)) %>% data.frame()
overlaps_bed_reads$pos <- paste0(overlaps_bed_reads$seqnames, "-", overlaps_bed_reads$start)

overlaps_bed_reads_filt <- overlaps_bed_reads %>% 
  filter(call_prob > 0.66) %>% 
  group_by(ref_position) %>% 
  mutate(expec_beta_filt = mean(call_code == "m")) %>% 
  ungroup() %>% 
  mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% 
  filter(match_beta_filt == TRUE)
head(overlaps_bed_reads_filt)
```

* now I have the positions and read_ids of the positions and reads I'm going to keep
* this is only for sample hu5.10
```{r}
bed_betas_hu5.10_filt <- bed_betas_hu5.10 %>% filter(pos %in% overlaps_bed_reads_filt$pos)
indiv_reads_filt <- indiv_reads %>% filter(read_id %in% overlaps_bed_reads_filt$read_id)
```

```{r}
# current alpha format
alpha_format_hu5.10_filt <- all_samples %>% filter(read_id %in% overlaps_bed_reads_filt$read_id) 
head(alpha_format_hu5.10_filt)
```


## Now let's play around

I have read structure and position structure

Traditional position structure:
```{r}
colnames(bed_betas_hu5.10_filt)[c(11,1:5,9)]
```

* actually place to start is with my overlaps_bed_reads_filt
* because it's already got betas plus reads
* all it needs is the alpha info
* and it's a ginormous data frame with all the info
* can't overlap alpha and beta file b/c alpha file is read positions so won't line up nicely enough

```{r}
colnames(alpha_format_hu5.10_filt)
```

* I want the read_start, read_end, read_length, meth_pattern, genom_positions, num_meth, total, alpha


```{r}
alpha_and_beta <- overlaps_bed_reads_filt %>% 
  mutate(read_start = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "read_start"],
         read_end = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "read_end"],
         read_length = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "read_length"],
         meth_pattern = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "meth_pattern"],
         genom_positions = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "genom_positions"],
         num_meth = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "num_meth"],
         total = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "total"],
         alpha = alpha_format_hu5.10_filt[match(.$read_id, alpha_format_hu5.10_filt$read_id), "alpha"])
head(alpha_and_beta)
```

* this is a form that has all the info, and is technically an approach - a beta centric

# position based
```{r}
alpha_and_beta[1:5,]
```
* every row is a position
* positions do repeat - b/c it's position per read
```{r}
alpha_and_beta %>% group_by(pos) %>% summarise(n=n()) %>%
  ggplot(aes(x = n)) +
  geom_bar()
```
* but majority of positions only occur once
* highlighting that reads don't often overlap


# read based
* honestly I don't think it's worth spending any time on this
* or at least not right now
* because I think the trick will be in separating things out

# some kind of combo
* maybe something like summarised experiment style?
* jovana spent a bit of time on this thinking at research sprint ages ago

Cpg positions link to beta values
Reads are a vector of cpg positions, and each read_id has an alpha value

* let's just split everything up and see what I can use to link them
** pos
** and maybe just row num if I order by cpg_pos

```{r}
cpg_pos_gr <- as_granges(distinct(alpha_and_beta[,c("seqnames", "start", "end", "width", "pos")]))
cpg_pos_gr
```
* keep pos in there as an identifier?
* or maybe it should be numbers increasing and then can use row numbers
* could do both

```{r}
beta_matrix <- cbind(distinct(alpha_and_beta[,c("pos", "beta")])$beta)
rownames(beta_matrix) <- distinct(alpha_and_beta[,c("pos", "beta")])$pos
colnames(beta_matrix) <- "hu5.10" # one column per sample
head(beta_matrix)
```

* I don't have coverage or methylation info and that's what I need - the bed file was missing it and I haven't tried again to estimate it straight from bam/indiv_files

* that was the beta based items
* now for the read - icky

* read positions - actually just granges might be simplest?
```{r}
read_pos_gr <- as_granges(distinct(mutate(alpha_and_beta, start = read_start, end = read_end, width = end - start + 1)[,c("seqnames", "start", "end", "width", "read_id")]))
read_pos_gr
```


```{r}
alpha_matrix <- as.matrix(distinct(alpha_and_beta[,c("alpha", "read_id")])$alpha)
rownames(alpha_matrix) <- distinct(alpha_and_beta[,c("alpha", "read_id")])$read_id
colnames(alpha_matrix) <- "hu5.10" # one column per sample
head(alpha_matrix)
```


* another matrix for meth pattern? - also I know I copied pat naming but I think I prefer M and U - clearer - also it's not C/T b/c not BS
* what about meth pattern as a list: meth pattern, and then inside the list is the read ids that it matches?
* also because matrix is for assay in sumexp - and assay is like counts things - so like my alpha, beta, meth, etc
```{r}
alpha_and_beta %>% distinct(meth_pattern, read_id) %>% group_by(meth_pattern) %>% summarise(n=n()) %>%
  ggplot(aes(x = n)) +
  geom_boxplot()
```

```{r}
meth_pattern_list <- split(distinct(alpha_and_beta, meth_pattern, read_id)$read_id, distinct(alpha_and_beta, meth_pattern, read_id)$meth_pattern)
meth_pattern_list$CTTTTCCT
```
* ooh this is cool


* ok I have some of my pieces of info
* can I find a way to put them together?
* maybe try to make a plot?




* I had been using bins but currently don't have bins
* that's ok I do
* worse though I need the read split up to know if each cpg on read is meth or unmeth
* wait just reverse the meth pattern split
* and as a row names the genom position
```{r}
read_pattern_list <- split(distinct(alpha_and_beta, meth_pattern, read_id)$meth_pattern, distinct(alpha_and_beta, meth_pattern, read_id)$read_id)
read_pattern_list <- lapply(read_pattern_list, function(vec) {
  unlist(strsplit(vec, split = ""))
})
```

```{r}
read_genom_list <- split(distinct(alpha_and_beta, genom_positions, read_id)$genom_positions, distinct(alpha_and_beta, genom_positions, read_id)$read_id)
read_genom_list <- lapply(read_genom_list, function(vec) {
  unlist(strsplit(vec, split = ","))
})

unlist(read_genom_list)
```

```{r}
#master_object <- c(cpg_pos_gr, read_pos_gr, beta_matrix, alpha_matrix, read_pattern_list, read_genom_list)
```



```{r}
overlap_bins_reads %>% filter(sample == "hu5.10") %>% group_by(bin_num) %>% summarise(n= n()) %>% .[order(.$n, decreasing = TRUE),] %>% .[1:5,]
```




## try to plot

```{r}
region_reads <- overlap_bins_reads %>% filter(bin_num == 2364, sample == "hu5.10") %>% .$read_id
```

```{r}
plot_region_info <- filter(data.frame(read_pos_gr), read_id %in% region_reads)
plot_region_info$alpha <- alpha_matrix[match(plot_region_info$read_id, rownames(alpha_matrix), "hu5.10")]
```

```{r}
plot_region_site <- unlist(read_genom_list)
plot_region_site <- plot_region_site[names(plot_region_site) %in% region_reads]
```

```{r}
ggplot() +
  geom_segment(data = plot_region_info, 
               aes(x = start, xend = end, y = alpha, yend = alpha), alpha = 0.3) +
  geom_point()
```




## ok I was overcomplicating it and the plot wasn't working
* let's try simpler

* beta can go with cpg positions b/c all the same
```{r}
cpg_pos_gr <- as_granges(distinct(alpha_and_beta[,c("seqnames", "start", "end", "width", "pos", "beta")]))
cpg_pos_gr
```

* alpha can go with read
```{r}
read_pos_gr <- as_granges(distinct(mutate(alpha_and_beta, start = read_start, end = read_end, width = end - start + 1)[,c("seqnames", "start", "end", "width", "read_id", "alpha")]))
read_pos_gr
```

* how big would the genomic ranges list be if it's a list per read or per position with all the cpgs and meth status of that position?
* this is the awkward one
* modkit just has it as a table
* I want to do a bit better than that

* this is where the tuples is interesting - but is limited to a set size
* and also the pat

* for now though
```{r}
read_pos_gr <- as_granges(distinct(mutate(alpha_and_beta, start = read_start, end = read_end, width = end - start + 1)[,c("seqnames", "start", "end", "width", "read_id", "alpha", "genom_positions", "meth_pattern", "total")]))
read_pos_gr
```

## try plot again
```{r}
region_reads <- overlap_bins_reads %>% filter(bin_num == 2364, sample == "hu5.10") %>% .$read_id
region_reads
```

```{r}
site_meth <- cbind(position = filter(data.frame(read_pos_gr), read_id %in% region_reads) %>% .$genom_positions %>% strsplit(",") %>% unlist() %>% as.double(), 
      meth = filter(data.frame(read_pos_gr), read_id %in% region_reads) %>% .$meth_pattern %>% strsplit("") %>% unlist()) %>% data.frame()
site_meth <- site_meth %>% mutate(site_is_unmeth = ifelse(meth == "T", TRUE, FALSE))

alpha_vec <- filter(data.frame(read_pos_gr), read_id %in% region_reads) %>% .$alpha 
rep_vec <- filter(data.frame(read_pos_gr), read_id %in% region_reads) %>% .$total 

site_meth <- cbind(site_meth, alpha = rep(x = alpha_vec, times = rep_vec))
site_meth$position <- as.double(site_meth$position)
```

```{r}
ggplot(data = filter(data.frame(read_pos_gr), read_id %in% region_reads)) +
  geom_segment(aes(x = start, xend = end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_point(data = site_meth, aes(x = position, y = alpha, shape = site_is_unmeth)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(data.frame(cpg_pos_gr), start >= min(site_meth$position), start <= max(site_meth$position)),
            aes(x = start, y = beta),
            linetype = "dashed")
```

this is ugly
and idk if its accurate
# this plot is a problem so let's figure it out

```{r}
ggplot(data = filter(data.frame(read_pos_gr), read_id %in% region_reads)) +
  geom_segment(aes(x = start, xend = end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_point(data = site_meth, aes(x = position, y = alpha, shape = site_is_unmeth, colour = )) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(data.frame(cpg_pos_gr), start >= min(site_meth$position), start <= max(site_meth$position)),
            aes(x = start, y = beta),
            linetype = "dashed") +
  scale_x_continuous(limits = c(11815580, 11815650))
```

* it could look wrong just from my data manipulation?

```{r}
alpha_and_beta %>% filter(start >= 11815500, end <= 11816100)
alpha_and_beta %>% filter(start >= 11815500, end <= 11816100) %>% distinct(read_id, meth_pattern, alpha)
alpha_and_beta %>% filter(ref_position >= 11815580, ref_position <= 11815650) %>% distinct(read_id, ref_position, call_code, beta) %>% .[order(.$ref_position),]
alpha_and_beta %>% filter(start >= 11815500, end <= 11816100) %>% distinct(ref_position, beta)
```
* ah I think on the plot they look closer together than they are
* also idk anymore (again)
```{r}
overlaps_bed_reads_filt %>% filter(ref_position >= 11815580, ref_position <= 11815650) %>% distinct()
```
```{r}
alpha_and_beta %>% filter(ref_position >= 11815580, ref_position <= 11815650) %>% distinct()
```
yep I've screwed up these positions do weird double ups but also not



## back to the beginning

* I want this to be the last time

```{r}
indiv_reads$read_and_pos <- paste0(indiv_reads$read_id, ":", indiv_reads$ref_position)
```


# sense check everything
* does everything match to a cpg site?

```{r}
distinct(indiv_reads, ref_position) %>% nrow()
nrow(cg_sites)
```


* indiv reads change start and end to the pos - not the read length
* make end ref_position + 1 to capture all positions on indiv reads
```{r}
find_overlaps(as_granges(cg_sites), as_granges(mutate(indiv_reads, start = ref_position, end = ref_position + 1))) %>% data.frame() %>% distinct(ref_position) %>% nrow()
find_overlaps(as_granges(cg_sites), as_granges(mutate(indiv_reads, start = ref_position, end = ref_position + 1))) %>% data.frame() %>% distinct(index) %>% nrow()
```

* am I getting double ups?

```{r}
find_overlaps(as_granges(cg_sites), as_granges(mutate(indiv_reads, start = ref_position, end = ref_position + 1))) %>% data.frame() %>% group_by(read_id, index) %>% summarise(n=n()) %>%
  filter(n > 1)

c(reads_with_double_ups = find_overlaps(as_granges(cg_sites), as_granges(mutate(indiv_reads, start = ref_position, end = ref_position + 1))) %>% data.frame() %>% group_by(read_id, index) %>% summarise(n=n()) %>% filter(n > 1) %>% ungroup() %>% distinct(read_id) %>% nrow(),
  positions_with_double_ups = find_overlaps(as_granges(cg_sites), as_granges(mutate(indiv_reads, start = ref_position, end = ref_position + 1))) %>% data.frame() %>% group_by(read_id, index) %>% summarise(n=n()) %>% filter(n > 1) %>% ungroup() %>% distinct(index) %>% nrow())
```

* yes oops
1534 instances
1096 reads / 1464 cpg_index

```{r}
find_overlaps(as_granges(cg_sites), as_granges(mutate(indiv_reads, start = ref_position, end = ref_position + 1))) %>% data.frame() %>% filter(read_id == "0020f01c-2762-458d-a442-cfa10005a64b")
```

```{r}
cg_sites[122078:122083,]
```

* ok so it's instances where 2 cpg sites in a row
* and modkit is 0 based coordinates [ref](https://nanoporetech.github.io/modkit/intro_extract.html)
* bsgenome I'm 98% sure is 1-based - and google ai says so as well
* so I need to convert 1
* google ai also says bed files are normally 0 based
* I must have modified it though because my bed file lines up with my cg file
* and I will always return to my cg file

```{r}
bed_betas_hu5.10 %>% filter(start >= 20031112, end <= 20031215)
```

```{r}
find_overlaps(as_granges(cg_sites), as_granges(mutate(indiv_reads, start = ref_position + 1, end = ref_position + 1))) %>% data.frame() %>% group_by(read_id, index) %>% summarise(n=n()) %>%
  filter(n > 1)
```
* nice

* make indiv reads 1 based: and change start and end to ref position, not read position
```{r}
indiv_reads$ref_position <- indiv_reads$ref_position + 1
indiv_reads$start <- indiv_reads$ref_position
indiv_reads$end <- indiv_reads$ref_position
```

```{r}
find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% group_by(read_and_pos) %>% summarise(n=n()) %>% filter(n> 1)
find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% group_by(pos) %>% summarise(n=n()) %>% filter(n> 1) %>% nrow()
```
* it's ok that bed positions double up as that's because of multiple reads
* but good I have no double up of read:pos pairs

* make the expected beta again
* first without filtering

* expected beta (mean m grouped by ref_position)

```{r}
find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m")) %>%
  ggplot(aes(x = expec_beta, y = beta)) +
  geom_point(alpha = 0.2)

find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m")) %>%
  ggplot(aes(x = expec_beta, y = beta)) +
  geom_count()
```
* again but filtering to call_prob > 0.66: used by modbam2bed (what the paper used to make bed file)
```{r}
find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m")) %>%
  ggplot(aes(x = expec_beta, y = beta)) +
  geom_point(alpha = 0.2)

find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m")) %>%
  ggplot(aes(x = expec_beta, y = beta)) +
  geom_count()
```
```{r}
find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta = ifelse(beta == expec_beta, TRUE, FALSE)) %>% group_by(match_beta) %>% summarise(n=n()) %>% ungroup() %>% mutate(prop = n/sum(n))
```


* with the filtering and then removing the sites that don't align
```{r}
find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m")) %>% ungroup() %>% filter(beta == expec_beta) %>%
  ggplot(aes(x = expec_beta, y = beta)) +
  geom_point(alpha = 0.2)

find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m")) %>% ungroup() %>% filter(beta == expec_beta) %>%
  ggplot(aes(x = expec_beta, y = beta)) +
  geom_count()
```

# now to add alphas into this
* calculate on the filtered calls, these positions are then ignored

* get meth_pattern again
* this time use M and U not C and T (wgbs specific)
```{r}
alpha_and_beta2 <- find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>%
  group_by(read_id) %>% .[order(.$alignment_start),] %>% 
  mutate(call_code = ifelse(call_code == "m", "M", "U")) %>%
  mutate(meth_pattern = paste(call_code, collapse = "")) %>%
  mutate(num_meth = str_count(meth_pattern, pattern = "M"),
         total = str_length(meth_pattern),
         alpha = num_meth/total) %>%
  mutate(genom_positions = paste0(ref_position, collapse = ",")) %>%
  ungroup()
alpha_and_beta2 <- alpha_and_beta2 %>% data.frame()
head(alpha_and_beta2)
```

* now how can I check that this is right?
* try to make the same plot I guess


* let's look at that specific section first though

```{r}
alpha_and_beta2 %>% filter(start >= 20031112, end <= 20031215)
```
* 6 positions good
* all on the same read

* let's look up that other problem position
```{r}
alpha_and_beta2 %>% filter(start == 18895995)
```
* yep just 1 read because we filter out the other one as it was low probability at that position

* ok let's see if the plot looks neater now

```{r}
region_reads <- overlap_bins_reads %>% filter(bin_num == 2364, sample == "hu5.10") %>% .$read_id
region_reads
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha, alpha = 0.2)) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), aes(x = ref_position, y = alpha, colour = call_code)) 
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha, alpha = 0.2)) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), aes(x = ref_position, y = alpha, colour = call_code)) +
  scale_size_area()
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha, alpha = 0.2)) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_line(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads), ref_position, beta), 
            aes(x = ref_position, y = beta), linetype = "dashed")
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha, alpha = 0.2)) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_line(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads), ref_position, beta), 
            aes(x = ref_position, y = beta), linetype = "dashed") +
  scale_x_continuous(limits = c(11815580, 11815650))
```

* ok that's more chaotic then it used to be so it may be right now
* though there's still the thing of looking at the reads it wasn't that many here?
* I need to add in cpg positions here

```{r}
min(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_start)
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha, alpha = 0.2)) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_line(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads), ref_position, beta), 
            aes(x = ref_position, y = beta), linetype = "dashed") +
  geom_vline(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_end)), aes(xintercept = start), colour = "green") +
  scale_x_continuous(limits = c(11815580, 11815650))
```
```{r}
distinct(filter(alpha_and_beta2, read_id %in% region_reads), ref_position, beta) %>% filter(ref_position >= 11815580, ref_position <= 11815650)
filter(alpha_and_beta2, read_id %in% region_reads) %>% filter(ref_position >= 11815580, ref_position <= 11815650) %>% group_by(ref_position)%>% summarise(n())
filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_end)) %>%
  filter(start >= 11815580, start <= 11815650)
cg_sites %>%
  filter(start >= 11815580, start <= 11815650)
```

* ah it's still a ref position thing
* my guess is it's ones on oppo strand

```{r}
alpha_and_beta2 %>% filter(ref_position >= 11815580, ref_position <= 11815650)
```

* yep it's ones that have ref_strand negative
* ok need to go back and adjust
* if strand is negative, ref_position - 1
(but for which column? - or for all?)
```{r}
rbind(indiv_reads %>% filter(ref_position %in% cg_sites$start) %>% group_by(mod_strand, ref_strand, ref_mod_strand) %>% summarise(n()),
indiv_reads %>% filter(ref_position %in% cg_sites$end) %>% group_by(mod_strand, ref_strand, ref_mod_strand) %>% summarise(n()))
```
* can use either
```{r}
indiv_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/indiv_reads.rds")
indiv_reads$ref_position <- indiv_reads$ref_position + 1 # convert to 1 based
indiv_reads <- indiv_reads %>% mutate(ref_position = ifelse(ref_strand == "-", ref_position - 1, ref_position))
indiv_reads$read_and_pos <- paste0(indiv_reads$read_id, ":", indiv_reads$ref_position)
indiv_reads$start <- indiv_reads$ref_position
indiv_reads$end <- indiv_reads$ref_position
alpha_and_beta2 <- find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>%
  group_by(read_id) %>% .[order(.$alignment_start),] %>% 
  mutate(call_code = ifelse(call_code == "m", "M", "U")) %>%
  mutate(meth_pattern = paste(call_code, collapse = "")) %>%
  mutate(num_meth = str_count(meth_pattern, pattern = "M"),
         total = str_length(meth_pattern),
         alpha = num_meth/total) %>%
  mutate(genom_positions = paste0(ref_position, collapse = ",")) %>%
  ungroup()
alpha_and_beta2 <- alpha_and_beta2 %>% data.frame()
head(alpha_and_beta2)
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_line(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads), ref_position, beta), 
            aes(x = ref_position, y = beta), linetype = "dashed") +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_end)), aes(x = start, xend = start, y = -0.2, yend = 0), colour = "green") +
  scale_x_continuous(limits = c(11815580, 11815650))
```
```{r}
filter(alpha_and_beta2, read_id %in% region_reads) %>% filter(ref_position >= 11815580, ref_position <= 11815650) %>% distinct(read_id, alpha)
```
```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>% filter(alignment_start >= 11815580)
```

* yay!
* now I just need it for all the samples

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_line(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads), ref_position, beta), 
            aes(x = ref_position, y = beta), linetype = "dashed") +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_end)), aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads[1:15]) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads[1:15]), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_line(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads[1:15]), ref_position, beta), 
            aes(x = ref_position, y = beta), linetype = "dashed") +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_end)), aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads[1:15]) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads[1:15]), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_point(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads[1:15]), ref_position, beta), 
            aes(x = ref_position, y = beta), shape = 4, size = 3) +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_end)), aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
```

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads[1:15]) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_point(data = filter(alpha_and_beta2, read_id %in% region_reads[1:15]), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_point(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads[1:15]), ref_position, beta), 
            aes(x = ref_position, y = beta), shape = 4, size = 3) +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_end)), aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
```

# transform into more pat style format
* jovana wants that style to plot

pat format is
chr | 1st pos. |  meth pat. | # occurences
chr1 | 500.    |.   MMUM.   |.  3

```{r}
alpha_and_beta2 %>% 
  mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
                           end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>%
  distinct(read_id, seqnames, start_pos, meth_pattern) %>% 
  group_by(seqnames, start_pos, meth_pattern) %>%
  summarise(n=n()) %>%
  head()

alpha_and_beta2 %>% 
  mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
                           end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>%
  distinct(read_id, seqnames, start_pos, meth_pattern) %>% 
  group_by(seqnames, start_pos, meth_pattern) %>%
  summarise(n=n()) %>%
  group_by(n) %>%
  summarise(n())
```

* that was easy to make actually
* except you don't really get the betas with it

* trying to add in alpha and genom pos messes it up


```{r}
alpha_and_beta2_pat <- alpha_and_beta2 %>% 
  mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1)) %>%
  distinct(read_id, seqnames, start_pos, meth_pattern) %>% 
  group_by(seqnames, start_pos, meth_pattern) %>% 
  summarise(n=n()) %>%
  ungroup()
nrow(alpha_and_beta2_pat)
alpha_and_beta2_pat[1:10,]
```

* ok I only get 1 extra row when I add in rest of info and I can live with that (for now)

```{r}
alpha_and_beta2_pat <- alpha_and_beta2 %>% 
  mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
         end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>% 
  filter(ref_position == start_pos) %>%
  distinct(read_id, seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  group_by(seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  summarise(n=n()) %>%
  ungroup()
nrow(alpha_and_beta2_pat)
alpha_and_beta2_pat[1:10,]
alpha_and_beta2_pat %>% group_by(n) %>% summarise(n())
```
```{r}
alpha_and_beta2_pat <- alpha_and_beta2_pat %>%
  mutate(start_pos = as.integer(start_pos),
         end_pos = as.integer(end_pos))
```

```{r}
ref_pos <- alpha_and_beta2 %>% filter(read_id %in% region_reads[1:15]) %>% .$ref_position
```

```{r}
alpha_and_beta2_pat %>% filter(start_pos %in% ref_pos) %>% 
  ggplot() +
  geom_point(aes(x = start_pos, y = alpha, size = n)) +
  geom_segment(aes(x = start_pos, xend = end_pos, y = alpha, yend = alpha), alpha = 0.2) 
```

```{r}
alpha_and_beta2_pat %>% filter(start_pos %in% ref_pos) %>% 
  ggplot() +
  geom_point(aes(x = start_pos, y = alpha, size = n)) +
  geom_segment(aes(x = start_pos, xend = end_pos, y = alpha, yend = alpha), alpha = 0.2) +
  geom_point(aes(x = start_pos, y = beta), shape = 4, size = 3, colour = "red") +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2_pat, start_pos %in% ref_pos)$start_pos), 
                             end <= max(filter(alpha_and_beta2_pat, start_pos %in% ref_pos)$end_pos)), 
               aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
```

# summarised experiment object style

assays: matrix object 
* store methylation states
* could I have rows as cpgs, columns as reads?
* yes it would be ginormous
* but also it would work - b/c dfs anyway are cpgs
* would just need NAs for the cpgs where reads don't cover them

* could then have another assay of beta values
* easy because just 1 value per cpg
* row = cpg, col = sample

* could have another assay of alpha values
* just 1 value per read
* row = read, col = sample

* I would have 2 matrices where row is same = cpg
* but 1 where row is read
* and this would mess with rowData and colData stuff 
* b/c they should match
* look I could make the first cpg represent the read in alpha
* but then it's an issue because there will be multiple reads that start at the same site
* which would mean repeat rows - or another column saying the num occurences - which becomes pat format

rowData
* metadata: annotation info etc for rows

colData
* metadata: annotation info etc for cols

rowRanges
* maybe i could use petehickey's genomicTuples here? to store positions in the granges?

# was meaning more for meth patterns analysis but maybe peter hickeys package could help?
"analysing, managing, and visualising meth tuples" (not quite a read but similar)

* hmm more about the pattern because it's setting the length
* and then counting reads
```{r}
#renv::install("PeteHaitch/MethylationTuples")
#library(MethylationTuples)
```
https://github.com/PeteHaitch/methtuple

?MethylationTuples::MethPat()
```{r}
#?MethylationTuples::MethPat()
```

pete hickey also has this [genomictuples bioconductor package](https://bioconductor.org/packages/release/bioc/vignettes/GenomicTuples/inst/doc/GenomicTuplesIntroduction.html)
interesting except that reads vary in num cpgs - this requires same
but it builds off granges

* could have this but in like a list situation
* so one ranges for each length of read
* which is actually what he has in the example
** but also potentially not?? - I need to play around with it
* but would get out of hand length wise
* pat is definitely a neater format than anything else

```{r}
library(GenomicTuples)
```

```{r}
alpha_and_beta2[1:4,c(1,6,8,18,19,31,33,39)] # 1 read
```

```{r}
gt4 <- GTuples(seqnames = Rle("chr22", 1),
          tuples = matrix(c(10522481,10522501,10522591,10522649), ncol =4),
          strand = Rle("*", 1),
          alpha = 0.5)
names(gt4) <- alpha_and_beta2$read_id[1]
gt4
```
```{r}
gt4$alpha
gt4@internalPos
gt4@internalPos[1]
gt4@ranges
gt4@ranges@start
```
* ok it's kinda cute
* and can extract the positions
* problem though is only works for same num cpgs
```{r}
alpha_and_beta2_pat %>% mutate(num_cpgs = nchar(meth_pattern)) %>% group_by(num_cpgs) %>% summarise(n=n()) %>% nrow()
```
* 53 gtuples objects - and that's just for this sample (and for chrom 22)
* even if we filtered some out - it's still a lot

```{r}
alpha_and_beta2_pat %>% mutate(num_cpgs = nchar(meth_pattern)) %>% group_by(num_cpgs) %>% summarise(n=n()) %>% .[1:10,]
```
* it would be 1517 for the 4tuple though
* if you were interested in a specific length, I think this is kind of nice
* I like that it has all the positions - and you can extract them

```{r}
alpha_and_beta2 %>% filter(total == 4) %>% distinct(read_id) %>% nrow()
alpha_and_beta2 %>% filter(total == 4) %>% distinct(genom_positions) %>% nrow()
alpha_and_beta2 %>% filter(total == 4) %>% distinct(genom_positions, alpha) %>% nrow()
```
* this is going to complicate it
* hold on this form is basically almost pat
* but with granges
* and honestly pat is probably better

```{r}
alpha_and_beta2 %>% filter(total == 4) %>% distinct(read_id) %>% nrow()
alpha_and_beta2 %>% filter(total == 4) %>% .$genom_positions %>% data.frame() %>% separate('.', into = c("a", "b", "c", "d"), sep = ",") %>% mutate(a = as.double(a), b = as.double(b), c = as.double(c), d = as.double(d)) %>% distinct()
```

```{r}
GTuples(seqnames = alpha_and_beta2 %>% filter(total == 4) %>% distinct(read_id, seqnames) %>% .$seqnames,
        tuples = 

```


```{r}
gt4 <- GTuples(seqnames = "chr22",
          tuples = matrix(c(10522481,10522501,10522591,10522649), ncol =4),
          strand = "*",
          alpha = 0.5)
names(gt4) <- alpha_and_beta2$read_id[1]
```


```{r}
Rle(c("chr1", "chr2", "chr1", "chr3"),
                              c(1, 3, 2, 4))
matrix(c(1:10, 2:11, 3:12), ncol = 3)
```
```{r}
seqinfo <- Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1")
gt3 <- GTuples(seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"),
                              c(1, 3, 2, 4)),
               tuples = matrix(c(1:10, 2:11, 3:12), ncol = 3),
               strand = Rle(strand(c("-", "+", "*", "+", "-")),
                            c(1, 2, 2, 3, 2)),
               score = 1:10, GC = seq(1, 0, length = 10), seqinfo = seqinfo)
names(gt3) <- letters[1:10]
gt3
```

seqinfo <- Seqinfo(paste0("chr", 1:3), c(1000, 2000, 1500), NA, "mock1")
gt3 <- GTuples(seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"),
                              c(1, 3, 2, 4)),
               tuples = matrix(c(1:10, 2:11, 3:12), ncol = 3),
               strand = Rle(strand(c("-", "+", "*", "+", "-")),
                            c(1, 2, 2, 3, 2)),
               score = 1:10, GC = seq(1, 0, length = 10), seqinfo = seqinfo)
names(gt3) <- letters[1:10]

# [pat format](https://github.com/nloyfer/wgbs_tools/blob/master/docs/pat_format.md)
* it does keep coming back to pat being a fairly elegant format
* my issue with it is just that you lose information
* but I guess actually you can just have other columns or bits and pieces to associate back to it

```{r}
alpha_and_beta2_pat[1:10,]
```
```{r}
alpha_and_beta2_pat %>% .[order(.$start_pos),]
```

* also hold up I could plot with the pat format
* lol i knew that that's how I made the simplified plot

```{r}
region_reads
```


# Instructions on making PAT format
```{r}
alpha_and_beta2
```

```{r}
indiv_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/indiv_reads.rds")
indiv_reads$ref_position <- indiv_reads$ref_position + 1 # convert to 1 based
indiv_reads <- indiv_reads %>% mutate(ref_position = ifelse(ref_strand == "-", ref_position - 1, ref_position))
indiv_reads$read_and_pos <- paste0(indiv_reads$read_id, ":", indiv_reads$ref_position)
indiv_reads$start <- indiv_reads$ref_position
indiv_reads$end <- indiv_reads$ref_position
alpha_and_beta2 <- find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>%
  group_by(read_id) %>% .[order(.$alignment_start),] %>% 
  mutate(call_code = ifelse(call_code == "m", "M", "U")) %>%
  mutate(meth_pattern = paste(call_code, collapse = "")) %>%
  mutate(num_meth = str_count(meth_pattern, pattern = "M"),
         total = str_length(meth_pattern),
         alpha = num_meth/total) %>%
  mutate(genom_positions = paste0(ref_position, collapse = ",")) %>%
  ungroup()
alpha_and_beta2 <- alpha_and_beta2 %>% data.frame()
head(alpha_and_beta2)
```


```{r}
alpha_and_beta2_pat <- alpha_and_beta2 %>% 
  mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
         end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>% 
  filter(ref_position == start_pos) %>%
  distinct(read_id, seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  group_by(seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  summarise(n=n()) %>%
  ungroup()
nrow(alpha_and_beta2_pat)
alpha_and_beta2_pat[1:10,]
alpha_and_beta2_pat %>% group_by(n) %>% summarise(n())

alpha_and_beta2_pat <- alpha_and_beta2_pat %>%
  mutate(start_pos = as.integer(start_pos),
         end_pos = as.integer(end_pos))
```

---
title: "plotAlphaAndBeta"
author: "caitlinpage"
date: "2025-09-01"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

## Introduction

```{r}
library(plyranges)
library(EnsDb.Hsapiens.v86)
library(data.table)

library(dplyr)
library(ggplot2)
```


# files
* stick with bedgraph betas for now
* and all_samples file
```{r}
all_samples <- readRDS("/researchers/caitlin.page/cf_nano/r_output/all_samples.rds")
overlap_bins_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/overlap_bins_reads.rds")
cg_sites <- readRDS("/researchers/caitlin.page/cf_nano/r_output/cg_sites.rds")
bed_betas <- readRDS("/researchers/caitlin.page/cf_nano/r_output/bed_betas.rds")
wt_beta_chr22 <- readRDS("/researchers/caitlin.page/cf_nano/r_output/wt_beta_chr22.rds")
```


# existing code

```{r}

# Plot a gene promoter region across all samples

pair_overlaps(as_granges(overlap_bins_reads), as_granges(ensdb_genes_filt_prom)) %>% data.frame() %>% dplyr::filter(gene_name == "MGAT3") %>%
  ggplot(aes(x = read_start, y = alpha, colour = sample, group = sample)) +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha)) +
  labs(title = "MGAT3") +
  theme(legend.position = "none") +
  facet_wrap(~type, nrow = 2)

## by cancer group

pair_overlaps(as_granges(overlap_bins_reads), as_granges(ensdb_genes_filt_prom)) %>% data.frame() %>% dplyr::filter(gene_name == "CYTH4") %>%
  ggplot(aes(x = read_start, y = alpha, colour = sample, group = sample)) +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha), linewidth = 1) +
  labs(title = "CYTH4") +
  facet_wrap(~cancer_group, nrow = 3) +
  theme_classic() +
  theme(legend.position = "none")

# 1 position per read joined by a line to see the trends more easily

pair_overlaps(as_granges(overlap_bins_reads), as_granges(ensdb_genes_filt_prom)) %>% data.frame() %>% dplyr::filter(gene_name == "CYTH4") %>%
  ggplot(aes(x = read_start, y = alpha, colour = sample, group = sample)) +
  geom_line() +
  labs(title = "CYTH4") +
  facet_wrap(~cancer_group, nrow = 3) +
  theme_classic() +
  theme(legend.position = "none")
```

```{r}
overlap_bins_reads %>% .[order(.$num_reads_in_bin, decreasing = TRUE),] %>% distinct(bin_num, num_reads_in_bin, var_alpha) %>% head()
```



```{r}
all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id)
```
```{r}
distinct_cpgs <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$genom_positions %>% strsplit(",") %>% unlist() %>% unique() %>% as.double()
distinct_cpgs <- data.frame(distinct_cpgs)
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample)) +
  geom_point(data = distinct_cpgs, aes(x = distinct_cpgs, y = -0.1)) +
  labs(title = "bin 3780") +
  theme(legend.position = "none") +
  facet_wrap(~type, nrow = 2)
```
```{r}
all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .[1:5,] %>% .$meth_pattern %>% strsplit("")
```
```{r}
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .[1:5,] %>% .$alpha 
alpha_vec
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .[1:5,] %>% .$total 
rep_vec
rep(x = alpha_vec, times = rep_vec)

```
```{r}
c(0.833, 0.857, 1, 1, 0) %>% class()
rep(c(0.833, 0.857, 1, 1, 0), times = c(6,7,1,1,1))
```
* of course it works when you just give it them - but not when you save the vector
```{r}
bin_cpgs <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$genom_positions %>% strsplit(",") %>% unlist() %>% as.double()
bin_cpgs <- data.frame(bin_cpgs)
bin_cpgs <- cbind(bin_cpgs, meth = all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$meth_pattern %>% strsplit("") %>% unlist())
bin_cpgs <- bin_cpgs %>% mutate(site_is_unmeth = ifelse(meth == "T", TRUE, FALSE))

```

```{r}
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$alpha 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 

bin_cpgs <- cbind(bin_cpgs, alpha = rep(x = alpha_vec, times = rep_vec))
bin_cpgs %>% head()
```


```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample)) +
  theme(legend.position = "none") +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16)) +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```
* almost - I still need grouping by sample

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>% head()
```

```{r}
bin_cpgs <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$genom_positions %>% strsplit(",") %>% unlist() %>% as.double()
bin_cpgs <- data.frame(bin_cpgs)
bin_cpgs <- cbind(bin_cpgs, meth = all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$meth_pattern %>% strsplit("") %>% unlist())
bin_cpgs <- bin_cpgs %>% mutate(site_is_unmeth = ifelse(meth == "T", TRUE, FALSE))

alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$alpha 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 

bin_cpgs <- cbind(bin_cpgs, alpha = rep(x = alpha_vec, times = rep_vec))
# sample
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$sample 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 
bin_cpgs <- cbind(bin_cpgs, sample = rep(x = alpha_vec, times = rep_vec))
# type
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$type 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 
bin_cpgs <- cbind(bin_cpgs, type = rep(x = alpha_vec, times = rep_vec))
```


```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample)) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```

* ooh pretty

* now I want to add beta values
```{r}
min(bin_cpgs$bin_cpgs)
```
```{r}
unique(overlap_bins_reads$sample)[c(12,8,13,3,9,10,1,2,5,6,11,4,7)]
```

```{r}
bed_betas$beta <- bed_betas$name
bed_betas %>% filter(start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs))
unique(bed_betas$sample)
```

* ew annoying the sample name isn't a perfect match
```{r}
grep(unique(overlap_bins_reads$sample)[1], unique(bed_betas$sample), value = TRUE)
```

```{r}
match_names <- cbind(sample_names = unique(overlap_bins_reads$sample)[c(12,8,13,3,9,10,1,2,5,6,11,4,7)], bed_names = unique(bed_betas$sample)) %>% data.frame()
```

```{r}
bed_betas$bed_sample <- bed_betas$sample
bed_betas <- bed_betas %>% mutate(sample = match_names[match(.$bed_sample, match_names$bed_names), "sample_names"])
```


```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample)) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(bed_betas, start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs)),
            aes(x = start, y = beta, colour = sample, group = sample),
            linetype = "dashed") +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```

* so that's a big old yikes
* and a post lunch problem

* little bit worried these don't match up



```{r}
bin_cpgs %>% filter(bin_cpgs == 18895995, sample == "hu5.10")
bed_betas %>% filter(start == 18895995, sample == "hu5.10")
```
* according to alpha information, this site should have beta of 0.5
* there are 2 reads at the same cpg site, and at one of them is a T and the other is C
* but the bedgraph file is saying beta = 1

```{r}
wt_beta_chr22_beta %>% filter(pos == "chr22-18895995", variable == "HU005.10.beta")
```
* well now I'm worried I got alpha wrong as well :(

```{r}
wt_beta_chr22 %>% filter(pos == "chr22-18895995")
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample)) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(bed_betas, start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs), sample == "hu5.10"),
            aes(x = start, y = beta, colour = sample, group = sample),
            linetype = "dashed") +
  labs(title = "bin 3780") +
  scale_x_continuous(limits = c(18896000, 18897000))
```
* oh dear this is bad
* but also some of it is right??

* but also maybe it's just a mismatch bit because I've got a few dots without any lines showing a read so maybe that's the problem
* but it doesn't explain that other position where

```{r}
filter(bin_cpgs, sample == "hu5.10", bin_cpgs >= 18896125, bin_cpgs <= 18896310) %>% .[order(.$bin_cpgs),]
bed_betas %>% filter(sample == "hu5.10", start >= 18896125, start <= 18896310)
wt_beta_chr22 %>% filter(start >= 18896125, start <= 18896310)
```
* this position is inconsistent: chr22-18896226, and chr22-18896304
* ooh maybe it's a probability thing??? - because I never filtered the sites
* original file time
```{r}
all_samples %>% filter(sample == "hu5.10") %>% head()
```


```{r}
filter(bin_cpgs, sample == "hu5.10", bin_cpgs >= 18896125, bin_cpgs <= 18896310) %>%
  ggplot(aes(x = bin_cpgs, y = alpha)) +
  geom_point(aes(shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth"))
```


```{r}
filter(bin_cpgs, sample == "hu5.10", bin_cpgs >= 18896125, bin_cpgs <= 18896310)
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10")
```

# original file - check probs




```{r}
modkit_files <- list.files("/researchers/caitlin.page/cf_nano/modkit_output")
modkit_files <- paste0("/researchers/caitlin.page/cf_nano/modkit_output/", modkit_files)
modkit_files
```

```{r}
indiv_reads <- fread(modkit_files[1])
indiv_reads <- indiv_reads[indiv_reads$chrom == "chr22",]

indiv_reads$seqnames <- indiv_reads$chrom
indiv_reads$start <- indiv_reads$alignment_start
indiv_reads$end <- indiv_reads$alignment_end

indiv_reads <- indiv_reads[grep("..CG.", indiv_reads$query_kmer),]
```

```{r}
indiv_reads %>% filter(ref_position >= 18896125, ref_position <= 18896320) %>% .[order(.$ref_position),] %>% .[,c(1,3:7,13,14,17)]
```
* this position is inconsistent: chr22-18896226, and chr22-18896304
```{r}
filter(bin_cpgs, sample == "hu5.10", bin_cpgs >= 18896125, bin_cpgs <= 18896310) %>% .[order(.$bin_cpgs),]
bed_betas %>% filter(sample == "hu5.10", start >= 18896125, start <= 18896310)
wt_beta_chr22 %>% filter(start >= 18896125, start <= 18896310)
```
* hold up 226 is 0 beta in bedgraph, and 1 in beta file
* in indiv: 226 is m but prob is low, 225 is unmeth with high prob
* I need to trust the bedgraphs because they were provided

* and I think I need to filter

* 10522590/591 is a single read/call that is unmod with prob > 0.9 but has fail = TRUE (if the base modification call fell below the pass threshold)
* in bedgraph it's 1, and in beta file it's also 1
* but why would modkit say that fail = TRUE when the call prob is so high??

```{r}
indiv_reads %>%
  ggplot(aes(x = log2(call_prob), colour = fail)) +
  geom_density()
indiv_reads %>%
  ggplot(aes(x = fail, y = call_prob, fill = fail)) +
  geom_boxplot()
indiv_reads %>% filter(fail == TRUE) %>% nrow()
```
* weird that you can have calls of a high prob that failed

* let's check a couple of these sites to see if I've figured it out

```{r}
indiv_reads %>% filter(ref_position == 10524770)
bed_betas %>% filter(sample == "hu5.10", start == 10524771)
```
* but this is one is a fail with high prob unmeth, and bedgraph is unmeth
```{r}
indiv_reads %>% filter(ref_position == 10522590)
bed_betas %>% filter(sample == "hu5.10", start == 10522591)
```
* and same here
```{r}
indiv_reads %>% filter(ref_position == 10527087)
bed_betas %>% filter(sample == "hu5.10", start == 10527088)
```
* all 3 of these have ignored that fail thing
```{r}
wt_beta_chr22 %>% filter(start == 10522591)
```

```{r}
bed_betas
```

```{r}
wt_beta_chr22 %>% filter(HU005.10.meth == 0) %>% nrow()
#unmeth is only 0 which is surely wrong
```


```{r}
wt_beta_chr22 %>% filter(HU005.10.cov > 2) %>% distinct(HU005.10.unmeth)
```


nm
## copied plot from checkAlphaAndBetaMatch.Rmd
```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.2) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(bed_betas, sample == "hu5.10", start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs)),
            aes(x = start, y = beta, colour = sample, group = sample),
            linetype = "dashed") +
  labs(title = "bin 3780: hu5.10") +
  scale_x_continuous(limits = c(18896000, 18897000))
```

## develop function

# plot copied from [joinAlphaAndBeta](joinAlphaAndBeta.html)
```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_line(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads), ref_position, beta), 
            aes(x = ref_position, y = beta), linetype = "dashed") +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads)$alignment_end)), aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
```



Still to determine
* how best to show betas (line is a bit messy)
** jovana suggested just an x instead

```{r}
alpha_and_beta2 %>% filter(read_id %in% region_reads[1:15]) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_count(data = filter(alpha_and_beta2, read_id %in% region_reads[1:15]), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_point(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads[1:15]), ref_position, beta), 
            aes(x = ref_position, y = beta), shape = 4, size = 3) +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_end)), aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")

alpha_and_beta2 %>% filter(read_id %in% region_reads[1:15]) %>% distinct(read_id, alignment_start, alignment_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = alignment_start, xend = alignment_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_point(data = filter(alpha_and_beta2, read_id %in% region_reads[1:15]), 
             aes(x = ref_position, y = alpha, colour = call_code)) +
  geom_point(data = distinct(filter(alpha_and_beta2, read_id %in% region_reads[1:15]), ref_position, beta), 
            aes(x = ref_position, y = beta), shape = 4, size = 3) +
  geom_segment(data = filter(cg_sites, start >= min(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_start), end <= max(filter(alpha_and_beta2, read_id %in% region_reads[1:15])$alignment_end)), aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
```



# jovana wants something more like pat
* she thinks having the indiv meth call is too much




## function
* how to select a region
Inputs
* region

* need read positions with alpha for read line
* read + cpgs on read + meth status of cpgs + alpha - dots
* cpg pos + betas - dotted line
* all cpg pos - lines

```{r}
plot_fn <- function(chrom = chrom, region = c(start, end), data_big = data_big) {
  chr <- chrom
  start <- region[1]
  end <- region[2]
  
  data <- data_big
}
```


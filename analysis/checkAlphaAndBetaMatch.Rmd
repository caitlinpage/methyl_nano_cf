---
title: "checkAlphaAndBetaMatch"
author: "caitlinpage"
date: "2025-09-03"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

Alpha values are obtained from [alpha](modkitOutputToReadFormat.html)

Beta values were first done in research sprint work: [day 1](researchSprint.html), [day 2](researchSprintB.html)

Beta values were then obtained again [here???](plotAlphaAndBeta.html)

Goal was to plot alpha and beta together, [plots](plotAlphaAndBeta.html)

But I think something went wrong and I no longer trust either my alpha or beta values
an

## Packages

```{r}
library(data.table)

library(plyranges)
library(tidyr)
library(dplyr)
library(ggplot2)
```
```{r}
all_samples <- readRDS("/researchers/caitlin.page/cf_nano/r_output/all_samples.rds")
overlap_bins_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/overlap_bins_reads.rds")
cg_sites <- readRDS("/researchers/caitlin.page/cf_nano/r_output/cg_sites.rds")
bed_betas <- readRDS("/researchers/caitlin.page/cf_nano/r_output/bed_betas.rds")
wt_beta_chr22 <- readRDS("/researchers/caitlin.page/cf_nano/r_output/wt_beta_chr22.rds")
indiv_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/indiv_reads.rds")
```

## Code for plot

* bin 3780 is the most dense (most number of cpgs)
* use that to plot
```{r}
overlap_bins_reads %>% .[order(.$num_reads_in_bin, decreasing = TRUE),] %>% .[1, c("bin_num", "num_reads_in_bin")]
```


```{r}
bin_cpgs <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$genom_positions %>% strsplit(",") %>% unlist() %>% as.double()
bin_cpgs <- data.frame(bin_cpgs)
bin_cpgs <- cbind(bin_cpgs, meth = all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$meth_pattern %>% strsplit("") %>% unlist())
bin_cpgs <- bin_cpgs %>% mutate(site_is_unmeth = ifelse(meth == "T", TRUE, FALSE))

alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$alpha 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 

bin_cpgs <- cbind(bin_cpgs, alpha = rep(x = alpha_vec, times = rep_vec))
# sample
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$sample 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 
bin_cpgs <- cbind(bin_cpgs, sample = rep(x = alpha_vec, times = rep_vec))
# type
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$type 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 
bin_cpgs <- cbind(bin_cpgs, type = rep(x = alpha_vec, times = rep_vec))
```


```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample)) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```
* this plot has alpha values and the methylation state for each cpg on a read

* split the plot by sample


```{r}
bed_betas %>% filter(sample == "hu5.10") %>% summary(.)
summary(wt_beta_chr22$HU005.10.unmeth)
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = type, group = sample)) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = type, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780") +
  facet_wrap(~sample)

overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = type, group = sample)) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = type, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780: hu5.10")
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10", alpha %in% c(0,1)) 
```

* oh if reads overlap each other they're not visible

```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = read_id, group = sample)) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780: hu5.10")
```
* need it to have the circle colours as well - read id in the bin_cpg
* but also maybe making the line thicker and then opaque would help?

```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.3) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780: hu5.10")
```
* that shows it a little bit

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.2) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```

```{r}
c(bins_20_highest_var = overlap_bins_reads %>% .[order(.$var_alpha, decreasing = TRUE),] %>% .$bin_num %>% unique() %>% .[1:20],
bins_20_lowest_var = overlap_bins_reads %>% .[order(.$var_alpha, decreasing = FALSE),] %>% .$bin_num %>% unique() %>% .[1:20])
```
* distribution of alpha by bin
```{r}
high_var_bins_20 <- overlap_bins_reads %>% .[order(.$var_alpha, decreasing = TRUE),] %>% .$bin_num %>% unique() 
low_var_bins_20 <- overlap_bins_reads %>% .[order(.$var_alpha, decreasing = FALSE),] %>% .$bin_num %>% unique() 
```

```{r}
overlap_bins_reads %>% filter(bin_num %in% high_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with highest var")

overlap_bins_reads %>% filter(bin_num %in% high_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with highest var") +
  facet_wrap(~type)
```
* something weird going on in one the bins in the healthy samples
* would have been nice if there was a distinct difference between the luad and healthy
* but also this is highest var bins overall - not necessarily bins with high var for either
* but I guess what we want would be bins with low var individually - but the meth is different

```{r}
overlap_bins_reads %>% filter(bin_num %in% low_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with lowest var")

overlap_bins_reads %>% filter(bin_num %in% low_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with lowest var") +
  facet_wrap(~type)

overlap_bins_reads %>% filter(bin_num %in% low_var_bins_20[1:10]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with lowest var")
```
* this is nice

* adding in betas
```{r}
match_names <- cbind(sample_names = unique(overlap_bins_reads$sample)[c(12,8,13,3,9,10,1,2,5,6,11,4,7)], bed_names = unique(bed_betas$sample)) %>% data.frame()

bed_betas$bed_sample <- bed_betas$sample
bed_betas <- bed_betas %>% mutate(sample = match_names[match(.$bed_sample, match_names$bed_names), "sample_names"])
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.2) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(bed_betas, start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs)),
            aes(x = start, y = beta, colour = sample, group = sample),
            linetype = "dashed") +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```


```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.2) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(bed_betas, sample == "hu5.10", start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs)),
            aes(x = start, y = beta, colour = sample, group = sample),
            linetype = "dashed") +
  labs(title = "bin 3780: hu5.10") +
  scale_x_continuous(limits = c(18896000, 18897000))
```
```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") 
filter(bed_betas, sample == "hu5.10", start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs))
```

```{r}
all_samples %>% filter(sample == "hu5.10", read_id %in% filter(overlap_bins_reads, bin_num == 3780, sample == "hu5.10")$read_id)
```

* maybe there's not actually a problem and it's just a messy plot?
* but there was something funny

# something weird and wrong

* only 2 reads overlapping this cpg site
* on 1 read, the site is meth, the other the site is unmeth
* beta should be 0.5, but it's 1
```{r}
bin_cpgs %>% filter(bin_cpgs == 18895995, sample == "hu5.10")
bed_betas %>% filter(start == 18895995, sample == "hu5.10")
```
```{r}
all_samples %>% filter(sample == "hu5.10") %>% .[grep(18895995, .$genom_positions),]
```

```{r}
indiv_reads %>% filter(ref_position == 18895995)
indiv_reads %>% filter(read_id %in% c("0d26cd7f-14c3-4877-9682-dd3f19d9a54c", "f57e628a-7b6d-4d3f-92ff-a7ea08d588ed")) %>% .[c(1,7),]
```
* so the unmeth read has prob < 0.8, and fail = TRUE
* but the other read also has fail = TRUE
* I guess if you were to say that if it is too low prob it becomes the other one that would fix this scenario

https://nanoporetech.github.io/modkit/faq.html - * the probability section for the calls

# check out the bedgraph

* could there be something wrong with the bedgraph??

To extract (stranded) methylation information from the mod_mapping.bam files, we used modbam2bed (https://github.com/epi2me-labs/modbam2bed) v.0.4.5, specifying a minimum probability threshold of 0.667, and filtering out positions with 0 confident reads using awk. The full command line was “modbam2bed --cpg -t 4 -a 0.333 -b 0.667 | awk ‘($5>0){print} > out.bed.” All coordinates are in GRCh38 and are 0-based. These files are named “*.5mC.cut0.667.hg38.bed.gz.” Column 11 corresponds to the percent of reads methylated. Modbam2bed does not provide a column for the actual number of reads that this percentage is based on, but it can be calculated from the other columns. readCount=(col5*col10)/1000. We also provide a simple bedgraph with just the methylation fraction (beta) values in files named “*cut0.667.hg38.sorted.bedgraph.gz.”

* could also be the bedgraph filtering with modbam2bed is different to the modkit filtering
* can modkit make bed files?
* it does: run that
/modkit/bed_modkit.sbatch
* hopefully they will then match up as they will have used the same parameters

# bed file from modkit

```{r}
list.files("/researchers/caitlin.page/cf_nano/modkit_output/bed")
```

```{r}
modkit_bed_hu5.10 <- read.table("/researchers/caitlin.page/cf_nano/modkit_output/bed/hu5.10.bed")
```

[colnames of bed file](https://nanoporetech.github.io/modkit/intro_pileup.html)
positions are 0 based

```{r}
colnames(modkit_bed_hu5.10) <- c("seqnames", "start", "end", "mod_base_code", "score_same_as_coverage", "strand", "start_pos", "end_pos", "colour", "coverage", "beta", "n_mod", "n_canon", "n_other_mod", "n_delete", "n_fail", "n_diff", "n_nocall")
```
```{r}
unique(modkit_bed_hu5.10$mod_base_code)
```

```{r}
summary(modkit_bed_hu5.10$coverage)
summary(modkit_bed_hu5.10$n_mod)
summary(modkit_bed_hu5.10$n_canon)
```
```{r}
modkit_bed_hu5.10_chr22 <- modkit_bed_hu5.10 %>% filter(seqnames == "chr22")
```

* here we go let's find that funky position again
18895995
```{r}
modkit_bed_hu5.10_chr22 %>% filter(start > 18895980) %>% head()
```
* and of course here it doesn't even exist as a position
* because we need another problem
* and the closest one to it is 2 bases off and is canon - beta is 0

* so maybe the positions are off - but still means the answer is wrong
* oh wait it doesn't automatically restrict to just cpgs (b/c I didn't do the cpg bit with the fasta - should try that again)

```{r}
find_overlaps(as_granges(modkit_bed_hu5.10_chr22), as_granges(cg_sites)) %>% data.frame() %>% head()
```

* so that's what I need but still that position is missing
* all the positions in extract calls should exist in the bed file I don't get why they don't
* extract calls does same filtering as pileup
* unless i did extract full accidentally??
```{r}
find_overlaps(as_granges(modkit_bed_hu5.10_chr22), as_granges(cg_sites)) %>% data.frame() %>%
  ggplot(aes(x = beta)) +
  geom_density()
```


```{r}
indiv_reads %>% filter(ref_position == 18895995)
indiv_reads %>% filter(ref_position > 18895980, ref_position < 18896100)
```
* oh so it should be 0 - but they should be the same position - ref_position is 0 based
```{r}
cg_sites %>% filter(start > 18895980) %>% head()
```




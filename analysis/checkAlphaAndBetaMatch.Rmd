---
title: "checkAlphaAndBetaMatch"
author: "caitlinpage"
date: "2025-09-03"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

Alpha values are obtained from [alpha](modkitOutputToReadFormat.html)

Beta values were first done in research sprint work: [day 1](researchSprint.html), [day 2](researchSprintB.html)

Beta values were then obtained again [here???](plotAlphaAndBeta.html)

Goal was to plot alpha and beta together, [plots](plotAlphaAndBeta.html)

But I think something went wrong and I no longer trust either my alpha or beta values
an

## Packages

```{r}
library(data.table)

library(plyranges)
library(tidyr)
library(dplyr)
library(ggplot2)
```
```{r}
all_samples <- readRDS("/researchers/caitlin.page/cf_nano/r_output/all_samples.rds")
overlap_bins_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/overlap_bins_reads.rds")
cg_sites <- readRDS("/researchers/caitlin.page/cf_nano/r_output/cg_sites.rds")
bed_betas <- readRDS("/researchers/caitlin.page/cf_nano/r_output/bed_betas.rds")
wt_beta_chr22 <- readRDS("/researchers/caitlin.page/cf_nano/r_output/wt_beta_chr22.rds")
indiv_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/indiv_reads.rds")
```

## Code for plot

* bin 3780 is the most dense (most number of cpgs)
* use that to plot
```{r}
overlap_bins_reads %>% .[order(.$num_reads_in_bin, decreasing = TRUE),] %>% .[1, c("bin_num", "num_reads_in_bin")]
```


```{r}
bin_cpgs <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$genom_positions %>% strsplit(",") %>% unlist() %>% as.double()
bin_cpgs <- data.frame(bin_cpgs)
bin_cpgs <- cbind(bin_cpgs, meth = all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$meth_pattern %>% strsplit("") %>% unlist())
bin_cpgs <- bin_cpgs %>% mutate(site_is_unmeth = ifelse(meth == "T", TRUE, FALSE))

alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$alpha 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 

bin_cpgs <- cbind(bin_cpgs, alpha = rep(x = alpha_vec, times = rep_vec))
# sample
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$sample 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 
bin_cpgs <- cbind(bin_cpgs, sample = rep(x = alpha_vec, times = rep_vec))
# type
alpha_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$type 
rep_vec <- all_samples %>% filter(read_id %in% filter(overlap_bins_reads, bin_num == 3780)$read_id) %>% .$total 
bin_cpgs <- cbind(bin_cpgs, type = rep(x = alpha_vec, times = rep_vec))
```


```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample)) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```
* this plot has alpha values and the methylation state for each cpg on a read

* split the plot by sample


```{r}
bed_betas %>% filter(sample == "hu5.10") %>% summary(.)
summary(wt_beta_chr22$HU005.10.unmeth)
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = type, group = sample)) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = type, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780") +
  facet_wrap(~sample)

overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = type, group = sample)) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = type, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780: hu5.10")
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10", alpha %in% c(0,1)) 
```

* oh if reads overlap each other they're not visible

```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = read_id, group = sample)) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780: hu5.10")
```
* need it to have the circle colours as well - read id in the bin_cpg
* but also maybe making the line thicker and then opaque would help?

```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.3) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780: hu5.10")
```
* that shows it a little bit

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.2) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```

```{r}
c(bins_20_highest_var = overlap_bins_reads %>% .[order(.$var_alpha, decreasing = TRUE),] %>% .$bin_num %>% unique() %>% .[1:20],
bins_20_lowest_var = overlap_bins_reads %>% .[order(.$var_alpha, decreasing = FALSE),] %>% .$bin_num %>% unique() %>% .[1:20])
```
* distribution of alpha by bin
```{r}
high_var_bins_20 <- overlap_bins_reads %>% .[order(.$var_alpha, decreasing = TRUE),] %>% .$bin_num %>% unique() 
low_var_bins_20 <- overlap_bins_reads %>% .[order(.$var_alpha, decreasing = FALSE),] %>% .$bin_num %>% unique() 
```

```{r}
overlap_bins_reads %>% filter(bin_num %in% high_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with highest var")

overlap_bins_reads %>% filter(bin_num %in% high_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with highest var") +
  facet_wrap(~type)
```
* something weird going on in one the bins in the healthy samples
* would have been nice if there was a distinct difference between the luad and healthy
* but also this is highest var bins overall - not necessarily bins with high var for either
* but I guess what we want would be bins with low var individually - but the meth is different

```{r}
overlap_bins_reads %>% filter(bin_num %in% low_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with lowest var")

overlap_bins_reads %>% filter(bin_num %in% low_var_bins_20[1:20]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with lowest var") +
  facet_wrap(~type)

overlap_bins_reads %>% filter(bin_num %in% low_var_bins_20[1:10]) %>%
  ggplot(aes(x = alpha, colour = as.factor(bin_num))) +
  geom_density() +
  labs(title = "Distribution of alpha in bins with lowest var")
```
* this is nice

* adding in betas
```{r}
match_names <- cbind(sample_names = unique(overlap_bins_reads$sample)[c(12,8,13,3,9,10,1,2,5,6,11,4,7)], bed_names = unique(bed_betas$sample)) %>% data.frame()

bed_betas$bed_sample <- bed_betas$sample
bed_betas <- bed_betas %>% mutate(sample = match_names[match(.$bed_sample, match_names$bed_names), "sample_names"])
```

```{r}
overlap_bins_reads %>% filter(bin_num == 3780) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.2) +
  geom_point(data = bin_cpgs, aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(bed_betas, start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs)),
            aes(x = start, y = beta, colour = sample, group = sample),
            linetype = "dashed") +
  labs(title = "bin 3780") +
  facet_wrap(~type, nrow = 2)
```


```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha, colour = sample, group = sample), alpha = 0.2) +
  geom_point(data = filter(bin_cpgs, sample == "hu5.10"), aes(x = bin_cpgs, y = alpha, shape = site_is_unmeth, colour = sample, group = sample)) +
  scale_shape_manual(values = c(`TRUE` = 1, `FALSE` = 16),
                     name = "Meth status", labels = c(`TRUE` = "Unmeth", `FALSE` = "Meth")) +
  geom_line(data = filter(bed_betas, sample == "hu5.10", start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs)),
            aes(x = start, y = beta, colour = sample, group = sample),
            linetype = "dashed") +
  labs(title = "bin 3780: hu5.10") +
  scale_x_continuous(limits = c(18896000, 18897000))
```
```{r}
overlap_bins_reads %>% filter(bin_num == 3780, sample == "hu5.10") 
filter(bed_betas, sample == "hu5.10", start >= min(bin_cpgs$bin_cpgs), start <= max(bin_cpgs$bin_cpgs))
```

```{r}
all_samples %>% filter(sample == "hu5.10", read_id %in% filter(overlap_bins_reads, bin_num == 3780, sample == "hu5.10")$read_id)
```

* maybe there's not actually a problem and it's just a messy plot?
* but there was something funny

# something weird and wrong

* only 2 reads overlapping this cpg site
* on 1 read, the site is meth, the other the site is unmeth
* beta should be 0.5, but it's 1
```{r}
bin_cpgs %>% filter(bin_cpgs == 18895995, sample == "hu5.10")
bed_betas %>% filter(start == 18895995, sample == "hu5.10")
```
```{r}
all_samples %>% filter(sample == "hu5.10") %>% .[grep(18895995, .$genom_positions),]
```

```{r}
indiv_reads %>% filter(ref_position == 18895995)
indiv_reads %>% filter(read_id %in% c("0d26cd7f-14c3-4877-9682-dd3f19d9a54c", "f57e628a-7b6d-4d3f-92ff-a7ea08d588ed")) %>% .[c(1,7),]
```
* so the unmeth read has prob < 0.8, and fail = TRUE
* but the other read also has fail = TRUE
* I guess if you were to say that if it is too low prob it becomes the other one that would fix this scenario

https://nanoporetech.github.io/modkit/faq.html - * the probability section for the calls

# check out the bedgraph

* could there be something wrong with the bedgraph??

To extract (stranded) methylation information from the mod_mapping.bam files, we used modbam2bed (https://github.com/epi2me-labs/modbam2bed) v.0.4.5, specifying a minimum probability threshold of 0.667, and filtering out positions with 0 confident reads using awk. The full command line was “modbam2bed --cpg -t 4 -a 0.333 -b 0.667 | awk ‘($5>0){print} > out.bed.” All coordinates are in GRCh38 and are 0-based. These files are named “*.5mC.cut0.667.hg38.bed.gz.” Column 11 corresponds to the percent of reads methylated. Modbam2bed does not provide a column for the actual number of reads that this percentage is based on, but it can be calculated from the other columns. readCount=(col5*col10)/1000. We also provide a simple bedgraph with just the methylation fraction (beta) values in files named “*cut0.667.hg38.sorted.bedgraph.gz.”

* could also be the bedgraph filtering with modbam2bed is different to the modkit filtering
* can modkit make bed files?
* it does: run that
/modkit/bed_modkit.sbatch
* hopefully they will then match up as they will have used the same parameters

# bed file from modkit

```{r}
list.files("/researchers/caitlin.page/cf_nano/modkit_output/bed")
```

```{r}
modkit_bed_hu5.10 <- read.table("/researchers/caitlin.page/cf_nano/modkit_output/bed/hu5.10.bed")
```

[colnames of bed file](https://nanoporetech.github.io/modkit/intro_pileup.html)
positions are 0 based

```{r}
colnames(modkit_bed_hu5.10) <- c("seqnames", "start", "end", "mod_base_code", "score_same_as_coverage", "strand", "start_pos", "end_pos", "colour", "coverage", "beta", "n_mod", "n_canon", "n_other_mod", "n_delete", "n_fail", "n_diff", "n_nocall")
```
```{r}
unique(modkit_bed_hu5.10$mod_base_code)
```

```{r}
summary(modkit_bed_hu5.10$coverage)
summary(modkit_bed_hu5.10$n_mod)
summary(modkit_bed_hu5.10$n_canon)
```
```{r}
modkit_bed_hu5.10_chr22 <- modkit_bed_hu5.10 %>% filter(seqnames == "chr22")
```

* here we go let's find that funky position again
18895995
```{r}
modkit_bed_hu5.10_chr22 %>% filter(start > 18895980) %>% head()
```
* and of course here it doesn't even exist as a position
* because we need another problem
* and the closest one to it is 2 bases off and is canon - beta is 0

* so maybe the positions are off - but still means the answer is wrong
* oh wait it doesn't automatically restrict to just cpgs (b/c I didn't do the cpg bit with the fasta - should try that again)

```{r}
find_overlaps(as_granges(modkit_bed_hu5.10_chr22), as_granges(cg_sites)) %>% data.frame() %>% head()
```

* so that's what I need but still that position is missing
* all the positions in extract calls should exist in the bed file I don't get why they don't
* extract calls does same filtering as pileup
* unless i did extract full accidentally??
```{r}
find_overlaps(as_granges(modkit_bed_hu5.10_chr22), as_granges(cg_sites)) %>% data.frame() %>%
  ggplot(aes(x = beta)) +
  geom_density()
```


```{r}
indiv_reads %>% filter(ref_position == 18895995)
indiv_reads %>% filter(ref_position > 18895980, ref_position < 18896100)
```
* oh so it should be 0 - but they should be the same position - ref_position is 0 based
```{r}
cg_sites %>% filter(start > 18895980) %>% head()
```


# new idea
* basically I think it's because I'm supposed to filter out reads that don't pass the probability thresh (0.8) / have fail = TRUE

```{r}
indiv_reads %>% group_by(fail) %>% summarise(n())
```
* weird that's a lot of fails
```{r}
indiv_reads %>% 
  ggplot(aes(x = call_prob, colour = fail)) +
  geom_density()

indiv_reads %>% 
  ggplot(aes(x = fail, y = call_prob, colour = fail)) +
  geom_boxplot()
```

* but is it about the fail or the call_prob???
* going to have to try both

* I do think the bed file beta values and positions are more reliable - if only b/c modkit is weird as
* but also should check with both

```{r}
indiv_reads %>% group_by(ref_position) %>% .[order(.$ref_position),] %>% mutate(n=n()) %>% filter(n>1)
```
```{r}
indiv_reads <- indiv_reads %>% mutate(seqnames = "chr22", start = ref_position, end = ref_position)
```
```{r}
indiv_reads <- indiv_reads %>% group_by(ref_position) %>% mutate(expec_beta = mean(call_code == "m"))
```

```{r}
bed_betas_hu5.10 <- bed_betas_hu5.10 %>% mutate(start = start - 1, width = 2)
```

```{r}
overlaps_bed_reads <- find_overlaps(as_granges(bed_betas_hu5.10), as_granges(indiv_reads)) %>% data.frame()
```

```{r}
overlaps_bed_reads$pos <- paste0(overlaps_bed_reads$seqnames, "-", overlaps_bed_reads$start)
```

```{r}
overlaps_bed_reads <- overlaps_bed_reads %>% mutate(prob_ge_0.8 = ifelse(call_prob >= 0.8, TRUE, FALSE))
```

```{r}
overlaps_bed_reads <- overlaps_bed_reads %>% mutate(beta_match = ifelse(beta == expec_beta, TRUE, FALSE))
```

```{r}
overlaps_bed_reads %>% group_by(beta_match) %>% summarise(n=n())
```
* ok this is good most do match
* let's look at what's happening in true and in false

* true for sense check
```{r}
overlaps_bed_reads %>% filter(beta_match == TRUE)
```



* false (hopefully its a prob thing)

```{r}
overlaps_bed_reads %>% filter(beta_match == FALSE) %>% group_by(prob_ge_0.8) %>% summarise(n=n())
```
* this is not saying what I was hoping
```{r}
overlaps_bed_reads %>% filter(beta_match == FALSE) %>% group_by(fail) %>% summarise(n=n())
```
```{r}
overlaps_bed_reads %>% filter(beta_match == FALSE) %>% group_by(prob_ge_0.8, fail) %>% summarise(n=n())
```

```{r}
overlaps_bed_reads %>% filter(beta_match == FALSE) %>% mutate(prob_g_0.95 = ifelse(call_prob > 0.95, TRUE, FALSE)) %>% group_by(prob_g_0.95, fail) %>% summarise(n=n())
```
* if I raise the prob threshold I'm still stuck with 1118 reads where prob is high and isn't a fail but beta doesn't match
* ooh maybe because I need to remove the other reads and then recalculate betas

* remove reads call prob < 0.8
```{r}
overlaps_bed_reads %>% filter(call_prob > 0.8) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% group_by(match_beta_filt) %>% summarise(n=n()) %>% ungroup() %>% mutate(prop = n/sum(n))
```
well that is less than 3241 which is what I started with
now 2097

```{r}
overlaps_bed_reads %>% filter(fail == FALSE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% group_by(match_beta_filt) %>% summarise(n=n()) %>% ungroup() %>% mutate(prop = n/sum(n))
```

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.8, fail == FALSE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% group_by(match_beta_filt) %>% summarise(n= n()) %>% ungroup() %>% mutate(prop = n/sum(n))
```

* can get it down to 1565 with some filtering

* of these - do any of the original expec get it right?
```{r}
overlaps_bed_reads %>% filter(call_prob > 0.8, fail == FALSE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% group_by(match_beta_filt) %>% filter(match_beta_filt == FALSE) %>% group_by(match_beta_filt, beta_match) %>% summarise(n())
```


```{r}
overlaps_bed_reads %>% filter(call_prob > 0.8, fail == TRUE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% group_by(match_beta_filt) %>% filter(match_beta_filt == FALSE)
```

modbam2bed actually uses threshold 0.66
which is likely different to modkit threshold (fail)
```{r}
summary(filter(indiv_reads, fail == TRUE)$call_prob)
```

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% group_by(match_beta_filt) %>% summarise(n= n()) %>% ungroup() %>% mutate(prop = n/sum(n))
```

```{r}
c(num_reads = overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% filter(match_beta_filt == FALSE) %>% distinct(read_id) %>% nrow(), 
  num_pos = overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% filter(match_beta_filt == FALSE) %>% distinct(pos) %>% nrow())
```

* oops wasn't doing this on distinct reads (be some double ups b/c overlap with pos)

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(read_id, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n= n()) %>% ungroup() %>% mutate(prop = n/sum(n))

overlaps_bed_reads %>% filter(call_prob > 0.8, fail == TRUE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(read_id, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n= n()) %>% ungroup() %>% mutate(prop = n/sum(n))

overlaps_bed_reads %>% filter(fail == TRUE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(read_id, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n=n()) %>% ungroup() %>% mutate(prop = n/sum(n))

overlaps_bed_reads %>% filter(call_prob > 0.8) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(read_id, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n=n()) %>% ungroup() %>% mutate(prop = n/sum(n))
```

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n= n()) %>% ungroup() %>% mutate(prop = n/sum(n))

overlaps_bed_reads %>% filter(call_prob > 0.8, fail == TRUE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n= n()) %>% ungroup() %>% mutate(prop = n/sum(n))

overlaps_bed_reads %>% filter(fail == TRUE) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n=n()) %>% ungroup() %>% mutate(prop = n/sum(n))

overlaps_bed_reads %>% filter(call_prob > 0.8) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt) %>% group_by(match_beta_filt) %>% summarise(n=n()) %>% ungroup() %>% mutate(prop = n/sum(n))
```


*look maybe its ok to have some be wrong as long as its small proportion
* all similar but best is filt > 0.66, then filt > 0.8 - basically only 2% are wrong

*so let's use 0.66 and move on for right now
* actually try matching them up

* oops I had forgotten to do distinct reads
* 0.66 is still best but now they're all close to 5% (well that is standard error)

(but also actually beta is about positions so should be distinct pos, not distinct read_id - still 66% is best - 1.8%)

* so it's < 2% of CpGs and < 5% of reads

* how wrong are the wrong ones with this approach?

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt, beta, expec_beta_filt) %>% mutate(diff_beta_minus_expec = beta - expec_beta_filt) %>%
  ggplot(aes(x = diff_beta_minus_expec)) +
  geom_density()
```

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt, beta, expec_beta_filt) %>% mutate(diff_beta_minus_expec = beta - expec_beta_filt) %>%
  ggplot(aes(x = match_beta_filt, y = diff_beta_minus_expec)) +
  geom_boxplot() +
  geom_violin()
```

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt, beta, expec_beta_filt) %>% mutate(diff_beta_minus_expec = beta - expec_beta_filt) %>%
  filter(match_beta_filt == FALSE) %>%
  ggplot(aes(x = diff_beta_minus_expec)) +
  geom_density()
```

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt, beta, expec_beta_filt) %>% mutate(diff_beta_minus_expec = beta - expec_beta_filt) %>% .$diff_beta_minus_expec %>% summary()
```

```{r}
overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% distinct(pos, match_beta_filt, beta, expec_beta_filt) %>% mutate(diff_beta_minus_expec = beta - expec_beta_filt) %>% filter(match_beta_filt == FALSE) %>% .$diff_beta_minus_expec %>% summary()
```

# use this filtering

* and the ones that don't match? 
* I say we just filter them out as well


```{r}
overlaps_bed_reads_filt <- overlaps_bed_reads %>% filter(call_prob > 0.66) %>% group_by(ref_position) %>% mutate(expec_beta_filt = mean(call_code == "m")) %>% ungroup() %>% mutate(match_beta_filt = ifelse(beta == expec_beta_filt, TRUE, FALSE)) %>% filter(match_beta_filt == TRUE)
```

* now I can use these positions from the bed file and these read ids to get alpha again
* does this also mean I could infer coverage?
* because that was the problem with the bed file - no coverage etc info



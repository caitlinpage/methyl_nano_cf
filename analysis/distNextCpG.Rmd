---
title: "distNextCpG"
author: "Caitlin Page"
date: "2025-12-11"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

## Packages

```{r}
library(annotatr)
library(data.table)
library(plyranges)
library(tidyr)
library(stringr)
library(dplyr)
library(ggplot2)
```

## Data Objects
```{r}
cg_sites <- cbind(data.frame(Biostrings::matchPattern("CG", BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38[["chr22"]])), seqnames = "chr22") %>% 
  mutate(pos = paste0(seqnames, "-", start)) %>%
  relocate(pos, seqnames)
cg_sites$index <- 1:nrow(cg_sites)
```


```{r}
source("../code/processData.R")
for_beta_all <- readRDS("/researchers/caitlin.page/cf_nano/r_output/rrbs_alpha_beta.rds")
#for_beta <- readRDS("../output/cluster_files/rrbs_alpha_beta.rds")
for_beta <- for_beta_all %>% filter(seqnames == "chr22")
rrbs_for_beta_pat <- pat_for_wgbs(for_beta)

for_beta <- for_beta %>% group_by(start) %>% mutate(coverage = n(), mean_alpha = mean(alpha)) %>% ungroup() %>% data.frame()
just_beta <- for_beta %>% distinct(start, beta, coverage, mean_alpha) %>% .[order(.$start),]

```


```{r}
for_beta %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  ggplot(aes(x = dist_to_next)) +
  geom_density()
```


# Pete Hickey: MethylationTuples
Thesis Chapter 7: Co-methylation

* I couldn't download the package
* but the math is Mantel-Haenszel odds ratio estimator
* in a 2 by 2 chi square table for neighbouring cpgs
* and distance between cpgs is also involved

* 2 x 2 x K table for each IPD (distance between 2 cpgs)

* I want table like

observ (X, Y)

      Y
    1   2.  total
  1 n11 n12
X 2 n21 n22
total
and 1 and 2 are U and M


* so it's a separate table for each distance
* maybe should try it separately for different total number of cpgs on read
* try for 2 cpgs on read

```{r}
for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>% .[1:5,]
```

```{r}
tab <- for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>%
  filter(dist_to_next == 2) %>% 
  ungroup() %>%
  mutate(row_factor = substr(meth_pattern, 1, 1),
         col_factor = substr(meth_pattern, 2, 2))
tab
with(tab, tapply(count, list(row_factor, col_factor), sum))
```

```{r}
chisq_table <- for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(cpg_1 = substr(meth_pattern, 1, 1),
         cpg_2 = substr(meth_pattern, 2, 2)) %>%
  group_by(dist_to_next) %>%
  reframe(tab = list(xtabs(count ~ cpg_1 + cpg_2, data = cur_data())))
chisq_table <- chisq_table$tab 
names(chisq_table) <- for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>%
  mutate(dist_to_next = paste0("dist_next_", dist_to_next)) %>%
  .$dist_to_next %>% unique()
chisq_table[1:2]
```
* do list and then convert to array I think
```{r}
chisq_table <- simplify2array(chisq_table)
```

```{r}
mh_test <- mantelhaen.test(chisq_table)
mh_test
```
```{r}
mh_test$estimate
```

* this version of the test I only get the summarised odds ratio
* need another package to get individual if I want to plot like Petes

[epiDisplay](https://rdrr.io/cran/epiDisplay/man/mhor.html)

```{r}
epiDisplay::mhor(mhtable = chisq_table)
```

```{r}
try <- capture.output(epiDisplay::mhor(mhtable = chisq_table, graph = FALSE))

try <- try %>% data.frame() %>% .[4:39,] %>% data.frame()
colnames(try) <- "all"


# sep the words and the numbers
try <- try %>% separate_wider_delim(cols = all, delim = " ", names = c("type", "dist", "numbers"), too_few = "align_start", too_many = "merge")

# sep the numbers
numeric_lines <- grep("-?\\d+\\.\\d{2,}.*-?\\d+\\.\\d{2,}.*-?\\d+\\.\\d{2,}", 
                      try, value = TRUE)
# to maintain the p-val
pattern <- "-?\\d+\\.\\d{2,}|[-+]?\\d+\\.?\\d*(?:[eE][-+]?\\d+)"

vals <- regmatches(
  numeric_lines,
  gregexpr(pattern, numeric_lines))

m <- do.call(rbind, vals)
m <- as.vector(m)
names(m) <- rep(c("OR", "lower_lim", "upper_lim", "p_value"), times = 35)
split_vals <- split(m, names(m))
df <- cbind.data.frame(split_vals)
df <- lapply(df, as.double) %>% data.frame()

# merge
try <- cbind(try[1:35,1:2], df[,c(2,1,4,3)])
try[1:5,]
```

```{r}
try <- try %>% mutate(IPD = as.numeric(sub(".*_", "", dist)))
try %>%
  ggplot(aes(x = IPD, y = OR)) +
  geom_point()
```
* this is basically one of Pete's plots
* comethylation is strongest for smaller IPD's, steadies out at IPD = 20
* this is consistent with Pete's work

* this was for reads with only 2 cpgs


* try for more

* need to split the meth pattern into groups of 2
```{r}
chisq_table <- for_beta %>%
  filter(total == 3) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start,
         meth_pattern = paste0(meth_status, lead(meth_status))) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(cpg_1 = substr(meth_pattern, 1, 1),
         cpg_2 = substr(meth_pattern, 2, 2)) %>% 
  filter(!grepl("A", .$meth_pattern)) %>%
  group_by(dist_to_next) %>%
  reframe(tab = list(xtabs(count ~ cpg_1 + cpg_2, data = cur_data())))
  
chisq_table <- chisq_table$tab 
names(chisq_table) <- for_beta %>%
  filter(total == 3) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start,
         meth_pattern = paste0(meth_status, lead(meth_status))) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  filter(!grepl("A", .$meth_pattern)) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>% 
  mutate(dist_to_next = paste0("dist_next_", dist_to_next)) %>%
  .$dist_to_next %>% unique()
chisq_table[1:2]
chisq_table <- simplify2array(chisq_table)
```

```{r}
try3 <- capture.output(epiDisplay::mhor(mhtable = chisq_table, graph = FALSE))

try3 <- try3 %>% data.frame() %>% .[4:36,] %>% data.frame()
colnames(try3) <- "all"


# sep the words and the numbers
try3 <- try3 %>% separate_wider_delim(cols = all, delim = " ", names = c("type", "dist", "numbers"), too_few = "align_start", too_many = "merge")

# sep the numbers
numeric_lines <- grep("-?\\d+\\.\\d{2,}.*-?\\d+\\.\\d{2,}.*-?\\d+\\.\\d{2,}", 
                      try3, value = TRUE)
# to maintain the p-val
pattern <- "-?\\d+\\.\\d{2,}|[-+]?\\d+\\.?\\d*(?:[eE][-+]?\\d+)"

vals <- regmatches(
  numeric_lines,
  gregexpr(pattern, numeric_lines))

m <- do.call(rbind, vals)
m <- as.vector(m)
names(m) <- rep(c("OR", "lower_lim", "upper_lim", "p_value"), times = 33)
split_vals <- split(m, names(m))
df <- cbind.data.frame(split_vals)
df <- lapply(df, as.double) %>% data.frame()

# merge
try3 <- cbind(try3[,1:2], df[,c(2,1,4,3)])
try3 <- try3 %>% mutate(IPD = as.numeric(sub(".*_", "", dist)))
try3[1:5,]
```

```{r}
try3 %>%
  ggplot(aes(x = IPD, y = OR)) +
  geom_point()
```
* why is it so different when the read has 3 cpgs? - I'm doing it the same way



```{r}
mantel_haen_dist_next_cpg <- function(long_data, num_cpg_read = NULL) {
  if(!is.null(num_cpg_read)) {
    format_data <- long_data %>%
        filter(total == num_cpg_read) 
  } else {format_data <- long_data}
  format_data <- format_data %>%
      group_by(read_id) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_pattern = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
      fill(dist_to_next, .direction = "down") %>%
      distinct(read_id, meth_pattern, dist_to_next) %>%
      filter(!grepl("A", .$meth_pattern)) %>%
      group_by(dist_to_next, meth_pattern) %>%
      summarise(count = n()) %>%
      ungroup()
  
  chisq_table <- format_data %>%
      mutate(cpg_1 = substr(meth_pattern, 1, 1),
             cpg_2 = substr(meth_pattern, 2, 2)) 
  # check for missing patterns (it screws up the chi test) and replace with 0
  missing_mm <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("MM", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_mm)) {
    chisq_table <- rbind(chisq_table, c(missing_mm[i], "MM", 0, "M", "M"))
  }
  missing_mu <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("MU", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_mu)) {
    chisq_table <- rbind(chisq_table, c(missing_mu[i], "MU", 0, "M", "U"))
  }
  missing_um <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("UM", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_um)) {
    chisq_table <- rbind(chisq_table, c(missing_um[i], "UM", 0, "U", "M"))
  }
  missing_uu <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("UU", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_uu)) {
    chisq_table <- rbind(chisq_table, c(missing_uu[i], "UU", 0, "U", "U"))
  }

  chisq_table$count <- as.integer(chisq_table$count)
  chisq_table$dist_to_next <- as.integer(chisq_table$dist_to_next)
  chisq_table <- chisq_table %>% filter(!is.na(dist_to_next))
  
  chisq_table <- chisq_table %>% 
      group_by(dist_to_next) %>%
      reframe(tab = list(xtabs(count ~ cpg_1 + cpg_2, data = cur_data())))
  chisq_table <- chisq_table$tab
  
  names(chisq_table) <- format_data %>%
      mutate(dist_to_next = paste0("dist_next_", dist_to_next)) %>%
      .$dist_to_next %>% 
    unique()
  distinct_rows <- format_data$dist_to_next %>% 
    unique() %>%
    length()
  chisq_table <- simplify2array(chisq_table)
  
  # the testing
  try <- capture.output(epiDisplay::mhor(mhtable = chisq_table, graph = FALSE))

  try <- try %>% data.frame() %>% .[4:(distinct_rows + 4),] %>% data.frame()
  colnames(try) <- "all"

  try <- try %>% separate_wider_delim(cols = all, delim = " ", names = c("type", "dist", "numbers"), too_few = "align_start", too_many = "merge")

  numeric_lines <- try$numbers
  # get Inf and d separate
  pattern <- "Inf|-Inf|[-+]?\\d+\\.?\\d*(?:[eE][-+]?\\d+)?"
  vals <- regmatches(
    numeric_lines,
    gregexpr(pattern, numeric_lines))

  m <- do.call(rbind, vals)
  m <- as.vector(m)
  names(m) <- rep(c("OR", "lower_lim", "upper_lim", "p_value"), times = (distinct_rows + 1))
  split_vals <- split(m, names(m))
  df <- cbind.data.frame(split_vals)
  df <- lapply(df, as.double) %>% data.frame()

  # merge
  try <- cbind(try[,1:2], df[,c(2,1,4,3)])
  try <- try %>% mutate(IPD = as.numeric(sub(".*_", "", dist)))
  try
}
#mantel_haen_dist_next_cpg(for_beta, 7) %>% .[1:5,]
```

```{r}
cpgs_read <- for_beta %>% distinct(total) %>% .[order(.$total),]
```
```{r}
mantel_haen_dist_next_cpg(for_beta, cpgs_read[2]) %>%
    ggplot(aes(x = IPD, y = OR)) +
    geom_point() +
    labs(title = paste0("total cpgs on read = ", cpgs_read[2]))
```

```{r}
plot_vec <- list()
for(x in 2:length(cpgs_read)) {
  plot <- mantel_haen_dist_next_cpg(for_beta, cpgs_read[x]) %>%
    ggplot(aes(x = IPD, y = OR)) +
    geom_point() +
    labs(title = paste0("total cpgs on read = ", cpgs_read[x]))
  plot_vec <- list(plot_vec, plot)
}
plot_vec
```

* the plot looks different for 2 and 3 now
* I don't know why the values have changed

* log the plots
```{r}
plot_vec <- list()
for(x in 2:length(cpgs_read)) {
  plot <- mantel_haen_dist_next_cpg(for_beta, cpgs_read[x]) %>%
    ggplot(aes(x = IPD, y = log2(OR))) +
    geom_point() +
    labs(title = paste0("total cpgs on read = ", cpgs_read[x]))
  plot_vec <- list(plot_vec, plot)
}
plot_vec
```

* I think Pete's plots are on the log axis but they are very different to mine
* they're positive and small log numbers

* maybe log10 instead of log2?
```{r}
plot_vec <- list()
for(x in 2:length(cpgs_read)) {
  plot <- mantel_haen_dist_next_cpg(for_beta, cpgs_read[x]) %>%
    ggplot(aes(x = IPD, y = log(OR))) +
    geom_point() +
    labs(title = paste0("total cpgs on read = ", cpgs_read[x]))
  plot_vec <- list(plot_vec, plot)
}
plot_vec
```


* all reads at once
```{r}
mantel_haen_dist_next_cpg(for_beta) %>%
    ggplot(aes(x = IPD, y = OR)) +
    geom_point() +
    labs(title = paste0("all reads together"))
```

* log the odds ratio
```{r}
mantel_haen_dist_next_cpg(for_beta) %>%
    ggplot(aes(x = IPD, y = log(OR))) +
    geom_point() +
    labs(title = paste0("all reads together"))
```

# why do they look weird?

```{r}
try_2 <- mantel_haen_dist_next_cpg(for_beta, 2)
```


```{r}
try_2[25:35,]

try_2 %>% 
  ggplot(aes(x = OR)) +
  geom_density()

try_2 %>% 
  ggplot(aes(x = OR)) +
  geom_density()
```

```{r}
log(1.520e-114)
log(1.520e-114 + 5)
```
* needs a constant to offset the effect of logging

```{r}
try_2 %>%
  ggplot(aes(x = IPD, y = OR)) +
  geom_point()

try_2 %>%
  ggplot(aes(x = IPD, y = log(OR))) +
  geom_point() +
  labs(title = "Log(OR)")

try_2 %>%
  ggplot(aes(x = IPD, y = log(OR + 5))) +
  geom_point() +
  labs(title = "Log(OR + 5)")
```

* looks way better now

```{r}
plot_vec <- list()
for(x in 2:length(cpgs_read)) {
  plot <- mantel_haen_dist_next_cpg(for_beta, cpgs_read[x]) %>%
    ggplot(aes(x = IPD, y = log(OR + 5))) +
    geom_point() +
    labs(title = paste0("log(OR+5), total cpgs on read = ", cpgs_read[x]))
  plot_vec <- list(plot_vec, plot)
}
plot_vec
```
* this looks better

* Pete found relationship was different when cpgs in islands vs not

# Split by in CGI or not

```{r}
annots <- c("hg38_cpgs")

annotations <- annotatr::build_annotations(genome = 'hg38', annotations = annots)
seqs <- annotations %>% data.frame() %>% distinct(seqnames) %>% .[1:22,]
annotations <- annotations %>% data.frame() %>% filter(seqnames %in% seqs)
```

```{r}
for_beta <- find_overlaps(as_granges(for_beta), as_granges(annotations)) %>% data.frame() %>%
  mutate(cgi = ifelse(type == "hg38_cpg_islands", "island", "not_island"))
```

```{r}
mantel_haen_dist_next_cpg(filter(for_beta, cgi == "island"), 2)[1:5,]
```
```{r}
try_2 %>%
  ggplot(aes(x = IPD, y = OR, fill = "red")) +
  geom_point() +
  geom_smooth()
```
```{r}
cpgs_read <- for_beta %>% distinct(total) %>% .[order(.$total),]
#for_beta %>% group_by(cgi) %>% distinct(total)
```
* there's a problem here about it cutting off cpgs from reads that border a cpg island, that's why the read length changed
* but I don't want to fix it right now
`x in 2:length(cpgs_read)`
```{r}
plot_vec <- list()
for(x in 2:8) {
  plot <- rbind(mantel_haen_dist_next_cpg(filter(for_beta, cgi == "island"), cpgs_read[x]) %>% mutate(cgi = "island"),
                mantel_haen_dist_next_cpg(filter(for_beta, cgi == "not_island"), cpgs_read[x]) %>% mutate(cgi = "not_island")) 
  plot <- plot %>%
    ggplot(aes(x = IPD, y = log(OR + 5), colour = cgi)) +
    geom_point() +
    labs(title = paste0("log(OR+5), total cpgs on read = ", cpgs_read[x]))
  plot_vec <- list(plot_vec, plot)
}
plot_vec
```

```{r}
plot_vec <- list()
for(x in 2:8) {
  plot <- rbind(mantel_haen_dist_next_cpg(filter(for_beta, cgi == "island"), cpgs_read[x]) %>% mutate(cgi = "island"),
                mantel_haen_dist_next_cpg(filter(for_beta, cgi == "not_island"), cpgs_read[x]) %>% mutate(cgi = "not_island")) 
  plot <- plot %>%
    ggplot(aes(x = IPD, y = log(OR + 5), colour = cgi)) +
    geom_point() +
    geom_smooth(aes(fill = cgi)) +
    labs(title = paste0("log(OR+5), total cpgs on read = ", cpgs_read[x]))
  plot_vec <- list(plot_vec, plot)
}
plot_vec
```


```{r}
rbind(mantel_haen_dist_next_cpg(filter(for_beta, cgi == "island")) %>% mutate(cgi = "island"),
                mantel_haen_dist_next_cpg(filter(for_beta, cgi == "not_island")) %>% mutate(cgi = "not_island")) %>%
    ggplot(aes(x = IPD, y = log(OR + 5), colour = cgi)) +
    geom_point() +
    geom_smooth(aes(fill = cgi)) +
    labs(title = paste0("all reads together"))
```

* when odds ratio is high, comethylation is strong
* when odds ratio is low, comethylation is weak
* so as expected, when distance between cpgs increases, comethylation is weaker

with cgu - results are similar
* this is consistent with Pete
* was unexpected for him
* but this is in the case of NIL = 0 (no skipping cpgs)

# where to take this next?
* would be good to do for NIL > 0 
** will require some adjusting of the function - specifying which `lead()` to use
* repeat for all chromosomes
* repeat on nanopore data
* maybe overlay gene features?

[NIL > 0](comethNILGrZero.html)



```{r}
nrow(for_beta_all)
length(unique(for_beta_all$seqnames))
seqs <- for_beta_all %>% distinct(seqnames) %>% .[order(.$seqnames),]
for_beta_all <- for_beta_all %>% filter(seqnames %in% seqs[1:25])
nrow(for_beta_all)
```

```{r}
#cometh_all <- mantel_haen_dist_next_cpg(for_beta_all)
#cometh_all
```
* it failed :(
* just run the steps


```{r}
  format_data <- for_beta_all %>%
      group_by(read_id) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_pattern = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
      fill(dist_to_next, .direction = "down") %>%
      distinct(read_id, meth_pattern, dist_to_next) %>%
      filter(!grepl("A", .$meth_pattern)) %>%
      group_by(dist_to_next, meth_pattern) %>%
      summarise(count = n()) %>%
      ungroup()
  
  chisq_table <- format_data %>%
      mutate(cpg_1 = substr(meth_pattern, 1, 1),
             cpg_2 = substr(meth_pattern, 2, 2)) 
  # check for missing patterns (it screws up the chi test) and replace with 0
  missing_mm <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("MM", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_mm)) {
    chisq_table <- rbind(chisq_table, c(missing_mm[i], "MM", 0, "M", "M"))
  }
  missing_mu <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("MU", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_mu)) {
    chisq_table <- rbind(chisq_table, c(missing_mu[i], "MU", 0, "M", "U"))
  }
  missing_um <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("UM", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_um)) {
    chisq_table <- rbind(chisq_table, c(missing_um[i], "UM", 0, "U", "M"))
  }
  missing_uu <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("UU", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_uu)) {
    chisq_table <- rbind(chisq_table, c(missing_uu[i], "UU", 0, "U", "U"))
  }

  chisq_table$count <- as.integer(chisq_table$count)
  chisq_table$dist_to_next <- as.integer(chisq_table$dist_to_next)
  chisq_table <- chisq_table %>% filter(!is.na(dist_to_next))
  
  chisq_table <- chisq_table %>% 
      group_by(dist_to_next) %>%
      reframe(tab = list(xtabs(count ~ cpg_1 + cpg_2, data = cur_data())))
  chisq_table <- chisq_table$tab
  
  names(chisq_table) <- format_data %>%
      mutate(dist_to_next = paste0("dist_next_", dist_to_next)) %>%
      .$dist_to_next %>% 
    unique()
  distinct_rows <- format_data$dist_to_next %>% 
    unique() %>%
    length()
  chisq_table <- simplify2array(chisq_table)
  
  # the testing
  try <- capture.output(epiDisplay::mhor(mhtable = chisq_table, graph = FALSE))

  try <- try %>% data.frame() %>% .[4:(distinct_rows + 4),] %>% data.frame()
  colnames(try) <- "all"

  try <- try %>% separate_wider_delim(cols = all, delim = " ", names = c("type", "dist", "numbers"), too_few = "align_start", too_many = "merge")

  numeric_lines <- try$numbers
  # get Inf and d separate
  pattern <- "Inf|-Inf|[-+]?\\d+\\.?\\d*(?:[eE][-+]?\\d+)?"
  vals <- regmatches(
    numeric_lines,
    gregexpr(pattern, numeric_lines))

  m <- do.call(rbind, vals)
  m <- as.vector(m)
  names(m) <- rep(c("OR", "lower_lim", "upper_lim", "p_value"), times = (distinct_rows + 1))
  split_vals <- split(m, names(m))
  df <- cbind.data.frame(split_vals)
  df <- lapply(df, as.double) %>% data.frame()

  # merge
  try <- cbind(try[,1:2], df[,c(2,1,4,3)])
  try <- try %>% mutate(IPD = as.numeric(sub(".*_", "", dist)))
  try[1:5,]
```

```{r}
format_data[1:5,]
```


* so possible other data I screwed up because it split the groups separately!!
```{r}
try %>%
  ggplot(aes(x = IPD, y = OR)) +
  geom_point()

try %>%
  ggplot(aes(x = IPD, y = log(OR))) +
  geom_point()
```

```{r}
rbind(mutate(try, source = "All_reads"), mutate(try_2, source = "reads_2cpgs")) %>% data.frame() %>%
  ggplot(aes(x = IPD, y = log(OR + 5), colour = source)) +
  geom_point()

```

* this is interesting
```{r}
rbind(mutate(try, source = "All_reads"), mutate(try_2, source = "reads_2cpgs")) %>% data.frame() %>% .[order(.$IPD),] %>% .[1:6,]
```

```{r}
for_beta_all_mantel <- for_beta_all %>%
  filter(total > 1) %>%
  group_by(read_id) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_and_next = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
  mutate(OR = try[match(.$dist_to_next, try$IPD), "OR"]) %>% filter(!grepl("A", .$meth_and_next))
for_beta_all_mantel[1:5,]
```

```{r}
for_beta_all_mantel %>%
  filter(alpha == 0) %>% group_by(dist_to_next, meth_and_next, OR) %>% summarise(n=n()) %>%
  ggplot(aes(x = dist_to_next, y = log(OR + 5))) +
  geom_point()

for_beta_all_mantel %>%
  filter(alpha == 0.5) %>% group_by(dist_to_next, meth_and_next, OR) %>% summarise(n=n()) %>%
  ggplot(aes(x = dist_to_next, y = log(OR + 5))) +
  geom_point()

for_beta_all_mantel %>%
  filter(alpha == 1) %>%
  ggplot(aes(x = dist_to_next, y = log(OR + 5))) +
  geom_point()
```
* can't figure out how to plot this
```{r}
for_beta_all_mantel %>%
  filter(alpha == 0.5) %>% group_by(dist_to_next, OR, meth_and_next) %>% summarise(n=n()) %>%
  ggplot(aes(x = dist_to_next, y = OR, colour = meth_and_next, size = n)) +
  geom_jitter()
```
* ok so it stays the same between patterns



```{r}
for_beta_all_mantel %>% filter(total == 4) %>%
  ggplot(aes(x = OR, colour = read_id)) +
  geom_density() +
  theme(legend.position = "none") +
  labs(title = "4 cpgs on read")
```



```{r}
read_ids <- for_beta_all_mantel %>% distinct(read_id) %>% mutate(simple_id = paste0("read_", 1:n())) %>% data.frame()
for_beta_all_mantel <- for_beta_all_mantel %>%
  mutate(simple_id = read_ids[match(.$read_id, read_ids$read_id), "simple_id"])
```

```{r}
for_beta_all_mantel %>% distinct(simple_id, total) %>% group_by(total) %>% summarise(n())
```

```{r}
for_beta_all_mantel %>%
  ggplot(aes(x = OR, colour = simple_id)) +
  geom_density() +
  facet_wrap(~ total) +
  theme(legend.position = "none")
```



########
* in thinking about if mm - what about the next one
* that's a tree diagram
* and in that case - you multiply the probability each time
* probability of m * m * m
* I don't know if there's a statistic associated with this concept
* because it's about either linking indep or dependent events
* and in this it's tricky because it's kinda both
* it's kinda dependent - but how dependent depends on a lot of things

########
* new idea: distribution of alpha by distance - distance and alphas to relate to this idea
* density of cpgs on read
* find where it failed

This file is too big so see here for [Cell free nanopore analysis](comethCfData.html)

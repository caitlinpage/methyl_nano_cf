---
title: "distNextCpG"
author: "Caitlin Page"
date: "2025-12-11"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

## Packages

```{r}
library(annotatr)
library(data.table)
library(plyranges)
library(tidyr)
library(stringr)
library(dplyr)
library(ggplot2)
```

## Data Objects
```{r}
cg_sites <- cbind(data.frame(Biostrings::matchPattern("CG", BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38[["chr22"]])), seqnames = "chr22") %>% 
  mutate(pos = paste0(seqnames, "-", start)) %>%
  relocate(pos, seqnames)
cg_sites$index <- 1:nrow(cg_sites)
```


```{r}
source("../code/processData.R")

for_beta <- readRDS("../output/cluster_files/rrbs_alpha_beta.rds")
for_beta <- for_beta %>% filter(seqnames == "chr22")
rrbs_for_beta_pat <- pat_for_wgbs(for_beta)

for_beta <- for_beta %>% group_by(start) %>% mutate(coverage = n(), mean_alpha = mean(alpha)) %>% ungroup() %>% data.frame()
just_beta <- for_beta %>% distinct(start, beta, coverage, mean_alpha) %>% .[order(.$start),]

```


```{r}
for_beta %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  ggplot(aes(x = dist_to_next)) +
  geom_density()
```

```{r}
for_beta %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup()
```

# Pete Hickey: MethylationTuples
* I couldn't download the package
* but the math is Mantel-Haenszel odds ratio estimator
* in a 2 by 2 chi square table for neighbouring cpgs
* and distance between cpgs is also involved

* 2 x 2 x K table for each IPD (distance between 2 cpgs)

* I want table like

observ (X, Y)

      Y
    1   2.  total
  1 n11 n12
X 2 n21 n22
total
and 1 and 2 are U and M

```{r}
?mantelhaen.test
```

```{r}
array(c(0, 0, 6, 5,
        3, 0, 3, 6,
        6, 2, 0, 4,
        5, 6, 1, 0,
        2, 5, 0, 0),
      dim = c(2, 2, 5),
      dimnames = list(
          Delay = c("None", "1.5h"),
          Response = c("Cured", "Died"),
          Penicillin.Level = c("1/8", "1/4", "1/2", "1", "4")))
```
* so it's a separate table for each distance
* maybe should try it separately for different total number of cpgs on read
* try for 2 cpgs on read

```{r}
for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n())
```

```{r}
tab <- for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>%
  filter(dist_to_next == 2) %>% 
  ungroup() %>%
  mutate(row_factor = substr(meth_pattern, 1, 1),
         col_factor = substr(meth_pattern, 2, 2))
tab
with(tab, tapply(count, list(row_factor, col_factor), sum))
```

```{r}
chisq_table <- for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  mutate(cpg_1 = substr(meth_pattern, 1, 1),
         cpg_2 = substr(meth_pattern, 2, 2)) %>%
  group_by(dist_to_next) %>%
  reframe(tab = list(xtabs(count ~ cpg_1 + cpg_2, data = cur_data())))
chisq_table <- chisq_table$tab 
names(chisq_table) <- for_beta %>%
  filter(total == 2) %>%
  group_by(read_id) %>%
  mutate(dist_to_next = lead(start) - start) %>%
  ungroup() %>%
  fill(dist_to_next, .direction = "down") %>%
  distinct(read_id, meth_pattern, dist_to_next) %>%
  group_by(dist_to_next, meth_pattern) %>%
  summarise(count = n()) %>%
  mutate(dist_to_next = paste0("dist_next_", dist_to_next)) %>%
  .$dist_to_next %>% unique()
chisq_table
```
* do list and then convert to array I think
```{r}
chisq_table <- simplify2array(chisq_table)
chisq_table
```

```{r}
mh_test <- mantelhaen.test(chisq_table)
mh_test
```
```{r}
mh_test$estimate
```

* this version of the test I only get the summarised odds ratio
* need another package to get individual if I want to plot like Petes

[epiDisplay](https://rdrr.io/cran/epiDisplay/man/mhor.html)

```{r}
epiDisplay::mhor(mhtable = chisq_table)
```

```{r}
try <- capture.output(epiDisplay::mhor(mhtable = chisq_table, graph = FALSE))
try %>% data.frame()
```

```{r}
try <- try %>% data.frame() %>% .[4:39,] %>% data.frame()
colnames(try) <- "all"
try
```


```{r}

try %>% separate_wider_delim(cols = all, delim = " ", names = c("type", "dist", "OR", "lower_lim", "upper_lim", "p_value"), too_few = "align_start", too_many = "merge")
```
* this is being a pain
* it won't split properly
* maybe ask ai again

```{r}
try <- try %>% separate_wider_delim(cols = all, delim = " ", names = c("type", "dist", "numbers"), too_few = "align_start", too_many = "merge")
try
```


```{r}
numeric_lines <- grep("-?\\d+\\.\\d{2,}.*-?\\d+\\.\\d{2,}.*-?\\d+\\.\\d{2,}", 
                      try, value = TRUE)

vals <- regmatches(
  numeric_lines,
  gregexpr("-?\\d+\\.\\d{2,}", numeric_lines)
)

m <- do.call(rbind, vals)
m <- as.vector(m)
names(m) <- rep(c("OR", "lower_lim", "upper_lim", "p_value"), times = 35)

split_vals <- split(m, names(m))
df <- cbind.data.frame(split_vals)

try <- cbind(try[1:35,], df[,c(2,1,4,3)])
```





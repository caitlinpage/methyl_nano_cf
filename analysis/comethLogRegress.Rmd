---
title: "comethLogRegress"
author: "caitlinpage"
date: "2026-02-05"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r}
library(annotatr)
library(data.table)
library(plyranges)
library(tidyr)
library(stringr)
library(dplyr)
library(ggplot2)
library(ROCR)
```

## Data Objects
```{r}
cg_sites <- cbind(data.frame(Biostrings::matchPattern("CG", BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38[["chr22"]])), seqnames = "chr22") %>% 
  mutate(pos = paste0(seqnames, "-", start)) %>%
  relocate(pos, seqnames)
cg_sites$index <- 1:nrow(cg_sites)
```


```{r}
source("../code/processData.R")
for_beta_all <- readRDS("/researchers/caitlin.page/cf_nano/r_output/rrbs_alpha_beta.rds")
#for_beta <- readRDS("../output/cluster_files/rrbs_alpha_beta.rds")
for_beta <- for_beta_all %>% filter(seqnames == "chr22")
rrbs_for_beta_pat <- pat_for_wgbs(for_beta)

for_beta <- for_beta %>% group_by(start) %>% mutate(coverage = n(), mean_alpha = mean(alpha)) %>% ungroup() %>% data.frame()
just_beta <- for_beta %>% distinct(start, beta, coverage, mean_alpha) %>% .[order(.$start),]

```


```{r}
mantel_haen_dist_next_cpg <- function(long_data, num_cpg_read = NULL) {
  if(!is.null(num_cpg_read)) {
    format_data <- long_data %>%
        filter(total == num_cpg_read) 
  } else {format_data <- long_data}
  format_data <- format_data %>%
      group_by(read_id) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_pattern = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
      fill(dist_to_next, .direction = "down") %>%
      distinct(read_id, meth_pattern, dist_to_next) %>%
      filter(!grepl("A", .$meth_pattern)) %>%
      group_by(dist_to_next, meth_pattern) %>%
      summarise(count = n()) %>%
      ungroup()
  
  chisq_table <- format_data %>%
      mutate(cpg_1 = substr(meth_pattern, 1, 1),
             cpg_2 = substr(meth_pattern, 2, 2)) 
  # check for missing patterns (it screws up the chi test) and replace with 0
  missing_mm <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("MM", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_mm)) {
    chisq_table <- rbind(chisq_table, c(missing_mm[i], "MM", 0, "M", "M"))
  }
  missing_mu <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("MU", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_mu)) {
    chisq_table <- rbind(chisq_table, c(missing_mu[i], "MU", 0, "M", "U"))
  }
  missing_um <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("UM", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_um)) {
    chisq_table <- rbind(chisq_table, c(missing_um[i], "UM", 0, "U", "M"))
  }
  missing_uu <- chisq_table %>% group_by(dist_to_next) %>% filter(!any(grepl("UU", meth_pattern))) %>% distinct(dist_to_next) %>% ungroup() %>% .$dist_to_next
  for(i in 1:length(missing_uu)) {
    chisq_table <- rbind(chisq_table, c(missing_uu[i], "UU", 0, "U", "U"))
  }

  chisq_table$count <- as.integer(chisq_table$count)
  chisq_table$dist_to_next <- as.integer(chisq_table$dist_to_next)
  chisq_table <- chisq_table %>% filter(!is.na(dist_to_next))
  
  chisq_table <- chisq_table %>% 
      group_by(dist_to_next) %>%
      reframe(tab = list(xtabs(count ~ cpg_1 + cpg_2, data = cur_data())))
  chisq_table <- chisq_table$tab
  
  names(chisq_table) <- format_data %>%
      mutate(dist_to_next = paste0("dist_next_", dist_to_next)) %>%
      .$dist_to_next %>% 
    unique()
  distinct_rows <- format_data$dist_to_next %>% 
    unique() %>%
    length()
  chisq_table <- simplify2array(chisq_table)
  
  # the testing
  try <- capture.output(epiDisplay::mhor(mhtable = chisq_table, graph = FALSE))

  try <- try %>% data.frame() %>% .[4:(distinct_rows + 4),] %>% data.frame()
  colnames(try) <- "all"

  try <- try %>% separate_wider_delim(cols = all, delim = " ", names = c("type", "dist", "numbers"), too_few = "align_start", too_many = "merge")

  numeric_lines <- try$numbers
  # get Inf and d separate
  pattern <- "Inf|-Inf|[-+]?\\d+\\.?\\d*(?:[eE][-+]?\\d+)?"
  vals <- regmatches(
    numeric_lines,
    gregexpr(pattern, numeric_lines))

  m <- do.call(rbind, vals)
  m <- as.vector(m)
  names(m) <- rep(c("OR", "lower_lim", "upper_lim", "p_value"), times = (distinct_rows + 1))
  split_vals <- split(m, names(m))
  df <- cbind.data.frame(split_vals)
  df <- lapply(df, as.double) %>% data.frame()

  # merge
  try <- cbind(try[,1:2], df[,c(2,1,4,3)])
  try <- try %>% mutate(IPD = as.numeric(sub(".*_", "", dist)))
  try
}
```


# try a logistic regression

[rbloggers](https://www.r-bloggers.com/2015/09/how-to-perform-a-logistic-regression-in-r/)
[statsandr](https://statsandr.com/blog/binary-logistic-regression-in-r/)
** longer blog post with more in detail description

* need data in the correct format
* more like the for_beta_all_mantel
* I think it's a binary model
* In the sense that it's either the same or different
* the next CpG - doesn't matter if first was m or u, it's just same or not same

```{r}
for_beta_log <- for_beta_all %>%
  filter(total > 1) %>%
  group_by(read_id) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_and_next = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
  filter(!grepl("A", .$meth_and_next)) %>%
  mutate(pattern_type = ifelse(meth_pattern == "MM" | meth_pattern == "UU", "same", "different"),
         pattern_value = ifelse(pattern_type == "same", 1, 0))
for_beta_log[,c("dist_to_next", "meth_and_next", "pattern_type", "pattern_value")]
```

```{r}
for_beta_log[1:1000,] %>%
  ggplot(aes(x = dist_to_next, y = pattern_value)) +
  geom_count()
```
* example looked better - 0s on left and 1s on right
* so regression worked
* geom_count kinda shows it looks a bit better - at least for 0

```{r}
nrow(for_beta_log)
```
* lots of data

* let's take first 1000 rows

```{r}
model <- glm(pattern_value ~ dist_to_next, data = for_beta_log[1:1000,], family = "binomial")
```

```{r}
summary(model)
```
* Pr < 0.05 as expected 
* this happens when data gets big very easily
* residual deviance we want to be close to 0: says a good fit
* this is quite high

* repeat for all rows

```{r}
for_beta_log %>%
  ggplot(aes(x = dist_to_next, y = pattern_value)) +
  geom_count()
```
* plot looks about the same
* interesting there's a clear aspect of distance for not same, but less clear for same
```{r}
model <- glm(pattern_value ~ dist_to_next, data = for_beta_log, family = "binomial")

summary(model)
```
* deviance is even higher


# add in cgi

```{r}
annots <- c("hg38_cpgs")

annotations <- annotatr::build_annotations(genome = 'hg38', annotations = annots)
seqs <- annotations %>% data.frame() %>% distinct(seqnames) %>% .[1:22,]
annotations <- annotations %>% data.frame() %>% filter(seqnames %in% seqs)

for_beta <- find_overlaps(as_granges(for_beta), as_granges(annotations)) %>% data.frame() %>%
  mutate(cgi = ifelse(type == "hg38_cpg_islands", "island", "not_island"))
```

```{r}
for_beta_log <- for_beta %>%
  filter(total > 1) %>%
  group_by(read_id, cgi) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_and_next = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
  filter(!grepl("A", .$meth_and_next)) %>%
  mutate(pattern_type = ifelse(meth_pattern == "MM" | meth_pattern == "UU", "same", "different"),
         pattern_value = ifelse(pattern_type == "same", 1, 0))
for_beta_log[,c("cgi", "dist_to_next", "meth_and_next", "pattern_type", "pattern_value")]
```

```{r}
for_beta_log %>%
  ggplot(aes(x = dist_to_next, y = pattern_value, colour = cgi)) +
  geom_count() +
  facet_wrap(~cgi)
```
* now we can see that it's really in the island that this distance thing with not same happens
* huh wait this has been saying that more commonly different in the close together
* was expecting the other way
* also I think this overall means it won't work very well

```{r}
model <- glm(pattern_value ~ ., data = for_beta_log[,c("cgi", "dist_to_next", "pattern_value")], family = "binomial")

summary(model)
```

```{r}
anova(model, test = "Chisq")
```
* add in cgi status and the meth_and_next
```{r}
model <- glm(pattern_value ~ ., data = for_beta_log[,c("cgi", "dist_to_next", "meth_and_next", "pattern_value")], family = "binomial")

summary(model)

anova(model, test = "Chisq")
```

# assess the models

```{r}
set.seed(123)
```

## just distance and same/diff

```{r}
for_beta_log <- for_beta_all %>%
  filter(total > 1) %>%
  group_by(read_id) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_and_next = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
  filter(!grepl("A", .$meth_and_next)) %>%
  mutate(pattern_type = ifelse(meth_pattern == "MM" | meth_pattern == "UU", "same", "different"),
         pattern_value = ifelse(pattern_type == "same", 1, 0))
for_beta_log <- for_beta_log[,c("dist_to_next", "pattern_type", "pattern_value")]
for_beta_log$row_id <- 1:nrow(for_beta_log)

train <- sample_n(for_beta_log, 100000)
test <- sample_n(filter(for_beta_log, !row_id %in% train$row_id), 50000)
```

```{r}
model <- glm(pattern_value ~ dist_to_next, data = train, family = "binomial")

summary(model)

p <- predict(model, newdata = test, type = "response")
pr <- prediction(p, test$pattern_value)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc
```

## dist and cgi

```{r}
for_beta_log <- for_beta %>%
  filter(total > 1) %>%
  group_by(read_id, cgi) %>%
      mutate(dist_to_next = lead(start) - start,
            meth_and_next = paste0(meth_status, lead(meth_status))) %>%
      ungroup() %>%
  filter(!grepl("A", .$meth_and_next)) %>%
  mutate(pattern_type = ifelse(meth_pattern == "MM" | meth_pattern == "UU", "same", "different"),
         pattern_value = ifelse(pattern_type == "same", 1, 0))
for_beta_log <- for_beta_log[,c("cgi", "dist_to_next", "meth_and_next", "pattern_type", "pattern_value")]
for_beta_log$row_id <- 1:nrow(for_beta_log)

train <- sample_n(for_beta_log, 100000)
test <- sample_n(filter(for_beta_log, !row_id %in% train$row_id), 50000)
```

```{r}
model <- glm(pattern_value ~ ., data = for_beta_log[,c("cgi", "dist_to_next", "pattern_value")], family = "binomial")

summary(model)

p <- predict(model, newdata = test, type = "response")
pr <- prediction(p, test$pattern_value)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc
```

## dist, cgi, meth_and_next

```{r}
model <- glm(pattern_value ~ ., data = for_beta_log[,c("cgi", "dist_to_next", "meth_and_next", "pattern_value")], family = "binomial")

summary(model)

p <- predict(model, newdata = test, type = "response")
pr <- prediction(p, test$pattern_value)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)
auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc
```
* this plot beats the cgi one by a bit, and beats the original one


# Conclusion

* I don't think this is an idea that works
* haven't spent a lot of time trying to interpret it yet
* and also it now has me confused about what mantel-haensz odds means
* auc plot looks best 3rd time, but still unsure of if it's good
* this may be something that looks better with the nil > 0
* also the data in the example looked better plotted - zeros down by left, 1s up by right
* mine is more an even spread - though I do get 0s down by left

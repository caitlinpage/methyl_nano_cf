---
title: "buildFunctions"
author: "caitlinpage"
date: "2025-10-29"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

## Introduction

```{r}
library(plyranges)
library(stringr)
library(BSgenome.Hsapiens.UCSC.hg38)
library(tidyr)
library(dplyr)
library(ggplot2)
library(data.table)
```

* starting a new file because outputs from modkit (nanopore) and bismark (wgbs + rrbs) are very very different
* and I want to get them in the same place

* then this also stays centralised as a way to make sure if I modify pieces other functions still run
* and I love making new files for new ideas
* so use this as an end to end workflow as well


* going from read+cpg to context with beta and alpha

# files
* pat file (with extra info) : gives alpha
* beta file
* og read level: has everything

* technically can get beta from alpha
* nanopore issue was figuring out the filtering metrics from modkit for that to be accurate

* will have to go through the same process for bismark files

# processing files
* from practical standpoint: use datatable and fread because files are LARGE

## helpers
```{r}
cg_sites <- cbind(data.frame(Biostrings::matchPattern("CG", BSgenome.Hsapiens.UCSC.hg38[["chr22"]])), seqnames = "chr22") %>% 
  mutate(pos = paste0(seqnames, "-", start)) %>%
  relocate(pos, seqnames)
cg_sites$index <- 1:nrow(cg_sites)
c(number_of_sites = nrow(cg_sites))
head(cg_sites)
```


## nanopore

* need modkit read file from modkit_extract_full
* bed file from downloaded data (bed file from modkit was weird)

* fread is a nightmare
```{r}
#fread(path_to_modkit_output)
process_modkit <- function(modkit_fread, path_to_bed_file) {
  reads <- modkit_fread
  reads <- reads$ref_position + 1 # convert to 1 based
  reads <- reads[, ref_position := ifelse(strand == "-", ref_position - 1, ref_position)] # convert to 1 based
  reads <- reads[, read_and_pos := paste0(reads$read_id, ":", reads$ref_position)]
  reads$start <- reads$ref_position
  reads$end <- reads$ref_position
  
  bed <- fread(path_to_bed_file)
  
  alpha_and_beta2 <- find_overlaps(as_granges(reads), as_granges(bed)) %>% data.frame() %>% 
    filter(call_prob > 0.66) %>% # solution for alpha and beta match
    group_by(read_id) %>% 
    .[order(.$alignment_start),] %>% 
    mutate(call_code = ifelse(call_code == "m", "M", "U")) %>% 
    mutate(meth_pattern = paste(call_code, collapse = "")) %>% 
    mutate(num_meth = str_count(meth_pattern, pattern = "M"),
         total = str_length(meth_pattern),
         alpha = num_meth/total) %>% 
    mutate(genom_positions = paste0(ref_position, collapse = ",")) %>% 
    ungroup()
  alpha_and_beta2 <- alpha_and_beta2 %>% data.frame()
  alpha_and_beta2
}

modkit_to_pat <- function(alpha_and_beta) {
  alpha_and_beta2_pat <- alpha_and_beta2 %>% 
    mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
           end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>% 
    filter(ref_position == start_pos) %>% 
    distinct(read_id, seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
    group_by(seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
    summarise(n=n()) %>% 
    ungroup()

  alpha_and_beta2_pat <- alpha_and_beta2_pat %>% 
    mutate(start_pos = as.integer(start_pos), 
           end_pos = as.integer(end_pos))
  alpha_and_beta2_pat
}
```


## wgbs/rrbs

* fread is a nightmare
* it won't run within a fn - doesn't trust the path
* but it's way faster than any other alternative
* so for now - read in the file with fread and then put that into the fn
```{r}
#read <- fread(file = path_to_bismark_res)
#bed <- fread(file = path_to_bed) # for betas - otherwise will make them myself
process_wgbs <- function(bismark, bed = NULL) {
  read <- bismark
  names(read) <- c("read_id", "strand", "seqnames", "start", "meth_status")
  read$end <- read$start
  
 # if (is.null(bed) == TRUE) {
#    read_overlap <- read
 # } else {
#  read_overlap <- find_overlaps(as_granges(read), as_granges(bed)) %>% data.frame()
 # }
  read_overlap <- read
  read_overlap[, meth_status := ifelse(meth_status == "Z", "M", "U")]
  read_overlap[, meth_pattern := paste0(meth_status, collapse = ""), by = read_id]
  read_overlap[, num_meth := str_count(meth_pattern, pattern = "M")]
  read_overlap[, total := str_length(meth_pattern)]
  read_overlap[, alpha := num_meth/total]
  read_overlap[, genom_positions := paste0(start, collapse = ","), by = read_id]

  read_overlap <- read_overlap %>% .[order(.$read_id),]
  
  betas <- betas_for_wgbs(read_overlap)
  betas <- data.frame(betas)
  read_overlap <- read_overlap %>% group_by(read_id) %>% 
    mutate(read_start = min(start), read_end = max(end), 
           genom_positions = paste0(start, collapse = ",")) %>% 
    ungroup()
  read_overlap <- read_overlap %>% data.frame() %>% 
    mutate(beta = betas[match(.$start, betas$start), "beta"])
  
  read_overlap
}


```
```{r}
betas_for_wgbs <- function(bismark_processed) {
  res <- bismark_processed %>% group_by(start, meth_status) %>% 
  .[order(.$start),] %>%
  mutate(meth_count_pos = n(), unmeth_count_pos = n()) %>%
  mutate(meth_count_pos = ifelse(meth_status == "M", meth_count_pos, NA),
         unmeth_count_pos = ifelse(meth_status == "U", unmeth_count_pos, NA)) %>% 
    ungroup() %>% 
    distinct(seqnames, start, end, meth_count_pos, unmeth_count_pos) %>%  
 group_by(start) %>% 
    .[order(.$meth_count_pos),] %>%
  fill(meth_count_pos, .direction = "down") %>%
  fill(unmeth_count_pos, .direction = "up") %>% 
  replace(is.na(.), 0) %>%
  mutate(beta = meth_count_pos/(meth_count_pos + unmeth_count_pos)) %>%
  ungroup() %>%
  distinct(seqnames, start, end, meth_count_pos, unmeth_count_pos, beta)
  
  res
}
```
```{r}
pat_for_wgbs <- function(process_res) {
  pat <- process_res %>% 
  mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
         end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>% 
  filter(start == start_pos) %>%
  distinct(read_id, seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  group_by(seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  summarise(n=n()) %>%
  ungroup()  %>%
  mutate(start_pos = as.integer(start_pos),
         end_pos = as.integer(end_pos))
  
  pat
}
```

```{r}
bis <- fread("/researchers/caitlin.page/rrbs_encode_cell_line/CpG_OT_ENCFF000LYO_bismark_bt2.txt")
for_beta <- process_wgbs(bis)
for_beta <- for_beta %>% filter(seqnames == "chr22")
rrbs_for_beta_pat <- pat_for_wgbs(for_beta)
```


# plotting

```{r}
plot_fn <- function(chrom = chrom, region = c(start, end), data_big = data_big, cg_sites = cg_sites) {
  chr <- chrom
  start <- region[1]
  end <- region[2]
  
  data <- data_big
  cpgs <- cg_sites
  
  data <- data %>% 
    filter(seqnames == chr,
           start >= start,
           end <= end) 
  data2 <- data %>%
    distinct(read_id, alignment_start, alignment_end, alpha)
  
  plot <- data2 %>% 
    ggplot() +
    geom_segment(aes(x = alignment_start, xend = alignment_end, #read length
                     y = alpha, yend = alpha), alpha = 0.2) +
    geom_point(data = data, 
             aes(x = ref_position, y = alpha, colour = call_code)) + # alpha dots, 1 per read
    geom_point(data = distinct(data, ref_position, beta),            # beta as X
            aes(x = ref_position, y = beta), shape = 4, size = 3) +
    geom_segment(data = filter(cpgs, start >= start, end <= end),    # green lines showing cpg positions
                 aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
  plot
}
```

```{r}
# provide vector of read ids
rrbs_plot <- function(long_data, read_ids, cpgs = cg_sites) {
  long_data %>% filter(read_id %in% read_ids) %>% 
    distinct(read_id, read_start, read_end, alpha) %>%
  ggplot() +
  geom_segment(aes(x = read_start, xend = read_end, y = alpha, yend = alpha), alpha = 0.2) +
  geom_point(data = filter(long_data, read_id %in% read_ids), 
             aes(x = start, y = alpha, colour = meth_status)) +
  geom_point(data = distinct(filter(long_data, read_id %in% read_ids), start, beta), 
            aes(x = start, y = beta), shape = 4, size = 3) +
  geom_segment(data = filter(cg_sites, start >= min(filter(long_data, read_id %in% read_ids)$start), 
                             end <= max(filter(long_data, read_id %in% read_ids)$end)), 
               aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
}
```



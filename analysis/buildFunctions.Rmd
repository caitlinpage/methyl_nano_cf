---
title: "buildFunctions"
author: "caitlinpage"
date: "2025-10-29"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

## Introduction

```{r}
library(plyranges)
library(stringr)
library(BSgenome.Hsapiens.UCSC.hg38)
library(dplyr)
library(ggplot2)
library(data.table)
```

* starting a new file because outputs from modkit (nanopore) and bismark (wgbs + rrbs) are very very different
* and I want to get them in the same place

* then this also stays centralised as a way to make sure if I modify pieces other functions still run
* and I love making new files for new ideas
* so use this as an end to end workflow as well


* going from read+cpg to context with beta and alpha

# files
* pat file (with extra info) : gives alpha
* beta file
* og read level: has everything

* technically can get beta from alpha
* nanopore issue was figuring out the filtering metrics from modkit for that to be accurate

* will have to go through the same process for bismark files

# processing files
* from practical standpoint: use datatable and fread because files are LARGE

## helpers
```{r}
cg_sites <- cbind(data.frame(Biostrings::matchPattern("CG", BSgenome.Hsapiens.UCSC.hg38[["chr22"]])), seqnames = "chr22") %>% 
  mutate(pos = paste0(seqnames, "-", start)) %>%
  relocate(pos, seqnames)
cg_sites$index <- 1:nrow(cg_sites)
c(number_of_sites = nrow(cg_sites))
head(cg_sites)
```


## nanopore

* need modkit read file from modkit_extract_full
* bed file from downloaded data (bed file from modkit was weird)
```{r}
process_modkit <- function(path_to_modkit_output, path_to_bed_file) {
  reads <- fread(path_to_modkit_output)
  reads <- reads$ref_position + 1 # convert to 1 based
  reads <- reads[, ref_position := ifelse(strand == "-", ref_position - 1, ref_position)] # convert to 1 based
  reads <- reads[, read_and_pos := paste0(reads$read_id, ":", reads$ref_position)]
  reads$start <- reads$ref_position
  reads$end <- reads$ref_position
  
  bed <- fread(path_to_bed_file)
  
  alpha_and_beta2 <- find_overlaps(as_granges(reads), as_granges(bed)) %>% data.frame() %>% 
    filter(call_prob > 0.66) %>% # solution for alpha and beta match
    group_by(read_id) %>% 
    .[order(.$alignment_start),] %>% 
    mutate(call_code = ifelse(call_code == "m", "M", "U")) %>% 
    mutate(meth_pattern = paste(call_code, collapse = "")) %>% 
    mutate(num_meth = str_count(meth_pattern, pattern = "M"),
         total = str_length(meth_pattern),
         alpha = num_meth/total) %>% 
    mutate(genom_positions = paste0(ref_position, collapse = ",")) %>% 
    ungroup()
  alpha_and_beta2 <- alpha_and_beta2 %>% data.frame()
  alpha_and_beta2
}

modkit_to_pat <- function(alpha_and_beta) {
  alpha_and_beta2_pat <- alpha_and_beta2 %>% 
    mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
           end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>% 
    filter(ref_position == start_pos) %>% 
    distinct(read_id, seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
    group_by(seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
    summarise(n=n()) %>% 
    ungroup()

  alpha_and_beta2_pat <- alpha_and_beta2_pat %>% 
    mutate(start_pos = as.integer(start_pos), 
           end_pos = as.integer(end_pos))
  alpha_and_beta2_pat
}
```


```{r}
indiv_reads <- readRDS("/researchers/caitlin.page/cf_nano/r_output/indiv_reads.rds")
indiv_reads$ref_position <- indiv_reads$ref_position + 1 # convert to 1 based
indiv_reads <- indiv_reads %>% mutate(ref_position = ifelse(ref_strand == "-", ref_position - 1, ref_position))
indiv_reads$read_and_pos <- paste0(indiv_reads$read_id, ":", indiv_reads$ref_position)
indiv_reads$start <- indiv_reads$ref_position
indiv_reads$end <- indiv_reads$ref_position
alpha_and_beta2 <- find_overlaps(as_granges(indiv_reads), as_granges(bed_betas_hu5.10)) %>% data.frame() %>% filter(call_prob > 0.66) %>%
  group_by(read_id) %>% .[order(.$alignment_start),] %>% 
  mutate(call_code = ifelse(call_code == "m", "M", "U")) %>%
  mutate(meth_pattern = paste(call_code, collapse = "")) %>%
  mutate(num_meth = str_count(meth_pattern, pattern = "M"),
         total = str_length(meth_pattern),
         alpha = num_meth/total) %>%
  mutate(genom_positions = paste0(ref_position, collapse = ",")) %>%
  ungroup()
alpha_and_beta2 <- alpha_and_beta2 %>% data.frame()
head(alpha_and_beta2)

alpha_and_beta2_pat <- alpha_and_beta2 %>% 
  mutate(start_pos = sapply(str_split(genom_positions, ","), head, 1),
         end_pos = sapply(str_split(genom_positions, ","), tail, 1)) %>% 
  filter(ref_position == start_pos) %>%
  distinct(read_id, seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  group_by(seqnames, start_pos, meth_pattern, alpha, end_pos, beta) %>% 
  summarise(n=n()) %>%
  ungroup()
nrow(alpha_and_beta2_pat)
alpha_and_beta2_pat[1:10,]
alpha_and_beta2_pat %>% group_by(n) %>% summarise(n())

alpha_and_beta2_pat <- alpha_and_beta2_pat %>%
  mutate(start_pos = as.integer(start_pos),
         end_pos = as.integer(end_pos))
```

## wgbs/rrbs

```{r}
process_wgbs <- function(path_to_bismark_res, path_to_bed) {
  read <- fread(path_to_bismark_res)
  names(read) <- c("read_id", "strand", "seqnames", "start", "meth_status")
  read$end <- read$start
  
  bed <- fread(path_to_bed)
  
  read_overlap <- find_overlaps(as_granges(read), as_granges(bed)) %>% data.frame()
  
  read_overlap[, meth_status := ifelse(meth_status == "Z", "M", "U")]
  read_overlap[, meth_pattern := paste0(meth_status, collapse = ""), by = read_id]
  read_overlap[, num_meth := str_count(meth_pattern, pattern = "M")]
  read_overlap[, total := str_length(meth_pattern)]
  read_overlap[, alpha := num_meth/total]
  read_overlap[, genom_positions := paste0(start, collapse = ","), by = read_id]

  read_overlap <- read_overlap %>% .[order(.$read_id),]
  
  read
}


```


```{r}
bismark_read_top_strand <- fread(paste0("/researchers/caitlin.page/pancreatic_cancer_wgbs/bismark_res/", "CpG_OT_SRR1646792_GSM1541788_38-Lg_rep1_BS-Seq_Homo_sapiens_Bisulfite-Seq_1_bismark_bt2_pe.txt"))
names(bismark_read_top_strand) <- c("seq_id", "strand", "seqnames", "start", "meth_status")

bismark_read_top_strand[, meth_status := ifelse(meth_status == "Z", "M", "U")]
bismark_read_top_strand[, meth_pattern := paste0(meth_status, collapse = ""), by = seq_id]
bismark_read_top_strand[, num_meth := str_count(meth_pattern, pattern = "M")]
bismark_read_top_strand[, total := str_length(meth_pattern)]
bismark_read_top_strand[, alpha := num_meth/total]
bismark_read_top_strand[, genom_positions := paste0(start, collapse = ","), by = seq_id]

bismark_read_top_strand <- bismark_read_top_strand %>% .[order(.$seq_id),]
bismark_read_top_strand[1:10,]
```



# plotting

```{r}
plot_fn <- function(chrom = chrom, region = c(start, end), data_big = data_big, cg_sites = cg_sites) {
  chr <- chrom
  start <- region[1]
  end <- region[2]
  
  data <- data_big
  cpgs <- cg_sites
  
  data <- data %>% 
    filter(seqnames == chr,
           start >= start,
           end <= end) 
  data2 <- data %>%
    distinct(read_id, alignment_start, alignment_end, alpha)
  
  plot <- data2 %>% 
    ggplot() +
    geom_segment(aes(x = alignment_start, xend = alignment_end, #read length
                     y = alpha, yend = alpha), alpha = 0.2) +
    geom_point(data = data, 
             aes(x = ref_position, y = alpha, colour = call_code)) + # alpha dots, 1 per read
    geom_point(data = distinct(data, ref_position, beta),            # beta as X
            aes(x = ref_position, y = beta), shape = 4, size = 3) +
    geom_segment(data = filter(cpgs, start >= start, end <= end),    # green lines showing cpg positions
                 aes(x = start, xend = start, y = -0.15, yend = -0.05), colour = "green")
  plot
}
```




